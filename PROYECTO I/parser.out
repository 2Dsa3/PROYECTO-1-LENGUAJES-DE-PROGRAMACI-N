Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    BLOCK_COMMENT
    BREAK
    CLASS
    COMPOSED_ASSIGN
    CONST
    CONTINUE
    DECREMENT
    DO
    DOC_COMMENT
    DOT
    DYNAMIC
    ELSE
    EQUALS
    EXTENDS
    FINAL
    FOR
    GREATER_EQ
    GREATER_THAN
    HASH
    IF
    IMPLEMENTS
    INCREMENT
    INTERFACE
    IS
    IS_NOT
    LESS_EQ
    LESS_THAN
    LINE_COMMENT
    NOT_EQUALS
    NULL
    OBJECT
    PRINT
    PRIVATE
    PROTECTED
    PUBLIC
    STRING_LITERAL
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> var_declaration
Rule 5     statement -> data_structure
Rule 6     var_declaration -> VARIABLE ASSIGN expression SEMICOLON
Rule 7     var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON
Rule 8     var_declaration -> type VARIABLE ASSIGN expression SEMICOLON
Rule 9     var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON
Rule 10    var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON
Rule 11    type -> VOID
Rule 12    type -> STRING
Rule 13    type -> LIST
Rule 14    type -> SET
Rule 15    type -> MAP
Rule 16    type -> STACK
Rule 17    type -> QUEUE
Rule 18    type -> TREE
Rule 19    type -> GRAPH
Rule 20    bool_type -> BOOL
Rule 21    num_type -> FLOAT
Rule 22    num_type -> INTEGER
Rule 23    num_type -> DOUBLE
Rule 24    expression -> bool_expression
Rule 25    expression -> num_expression
Rule 26    expression -> VARIABLE
Rule 27    bool_expression -> TRUE
Rule 28    bool_expression -> FALSE
Rule 29    num_expression -> NUMBER
Rule 30    num_expression -> INTEGER
Rule 31    num_expression -> FLOAT
Rule 32    bool_expression -> NEGATION bool_expression
Rule 33    bool_expression -> bool_expression AND bool_expression
Rule 34    bool_expression -> bool_expression OR bool_expression
Rule 35    num_expression -> num_expression PLUS num_expression
Rule 36    num_expression -> num_expression MINUS num_expression
Rule 37    num_expression -> num_expression TIMES num_expression
Rule 38    num_expression -> num_expression DIVIDE num_expression
Rule 39    num_expression -> num_expression INTEGER_DIVIDE num_expression
Rule 40    num_expression -> num_expression MODULE num_expression
Rule 41    bool_expression -> LPAREN bool_expression RPAREN
Rule 42    num_expression -> LPAREN num_expression RPAREN
Rule 43    data_structure -> list_structure
Rule 44    data_structure -> map_structure
Rule 45    list_structure -> LSQUARE elements RSQUARE
Rule 46    map_structure -> LBRACE key_value_pairs RBRACE
Rule 47    elements -> elements COMMA expression
Rule 48    elements -> expression
Rule 49    key_value_pairs -> key_value_pairs COMMA key_value
Rule 50    key_value_pairs -> key_value
Rule 51    key_value -> expression COLON expression

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 33
AS                   : 
ASSIGN               : 6 8 9 10
BLOCK_COMMENT        : 
BOOL                 : 20
BREAK                : 
CLASS                : 
COLON                : 51
COMMA                : 47 49
COMPOSED_ASSIGN      : 
CONST                : 
CONTINUE             : 
DECREMENT            : 
DIVIDE               : 38
DO                   : 
DOC_COMMENT          : 
DOT                  : 
DOUBLE               : 23
DYNAMIC              : 
ELSE                 : 
EQUALS               : 
EXTENDS              : 
FALSE                : 28
FINAL                : 
FLOAT                : 21 31
FOR                  : 
GRAPH                : 19
GREATER_EQ           : 
GREATER_THAN         : 
HASH                 : 
IF                   : 
IMPLEMENTS           : 
INCREMENT            : 
INTEGER              : 22 30
INTEGER_DIVIDE       : 39
INTERFACE            : 
IS                   : 
IS_NOT               : 
LBRACE               : 46
LESS_EQ              : 
LESS_THAN            : 
LINE_COMMENT         : 
LIST                 : 13
LPAREN               : 41 42
LSQUARE              : 45
MAP                  : 15
MINUS                : 36
MODULE               : 40
NEGATION             : 32
NOT_EQUALS           : 
NULL                 : 
NULL_ASSIGN          : 7
NUMBER               : 29
OBJECT               : 
OR                   : 34
PLUS                 : 35
PRINT                : 
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUEUE                : 17
RBRACE               : 46
RPAREN               : 41 42
RSQUARE              : 45
SEMICOLON            : 6 7 8 9 10
SET                  : 14
STACK                : 16
STRING               : 12
STRING_LITERAL       : 
TIMES                : 37
TREE                 : 18
TRUE                 : 27
VARIABLE             : 6 7 8 9 10 26
VOID                 : 11
WHILE                : 
error                : 

Nonterminals, with rules where they appear

bool_expression      : 9 24 32 33 33 34 34 41
bool_type            : 9
data_structure       : 5
elements             : 45 47
expression           : 6 7 8 47 48 51 51
key_value            : 49 50
key_value_pairs      : 46 49
list_structure       : 43
map_structure        : 44
num_expression       : 10 25 35 35 36 36 37 37 38 38 39 39 40 40 42
num_type             : 10
program              : 0
statement            : 2 3
statements           : 1 2
type                 : 8
var_declaration      : 4

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (7) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (8) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (9) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (10) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (43) data_structure -> . list_structure
    (44) data_structure -> . map_structure
    (11) type -> . VOID
    (12) type -> . STRING
    (13) type -> . LIST
    (14) type -> . SET
    (15) type -> . MAP
    (16) type -> . STACK
    (17) type -> . QUEUE
    (18) type -> . TREE
    (19) type -> . GRAPH
    (20) bool_type -> . BOOL
    (21) num_type -> . FLOAT
    (22) num_type -> . INTEGER
    (23) num_type -> . DOUBLE
    (45) list_structure -> . LSQUARE elements RSQUARE
    (46) map_structure -> . LBRACE key_value_pairs RBRACE

    VARIABLE        shift and go to state 6
    VOID            shift and go to state 12
    STRING          shift and go to state 13
    LIST            shift and go to state 14
    SET             shift and go to state 15
    MAP             shift and go to state 16
    STACK           shift and go to state 17
    QUEUE           shift and go to state 18
    TREE            shift and go to state 19
    GRAPH           shift and go to state 20
    BOOL            shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    DOUBLE          shift and go to state 24
    LSQUARE         shift and go to state 25
    LBRACE          shift and go to state 26

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    type                           shift and go to state 7
    bool_type                      shift and go to state 8
    num_type                       shift and go to state 9
    list_structure                 shift and go to state 10
    map_structure                  shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (7) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (8) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (9) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (10) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (43) data_structure -> . list_structure
    (44) data_structure -> . map_structure
    (11) type -> . VOID
    (12) type -> . STRING
    (13) type -> . LIST
    (14) type -> . SET
    (15) type -> . MAP
    (16) type -> . STACK
    (17) type -> . QUEUE
    (18) type -> . TREE
    (19) type -> . GRAPH
    (20) bool_type -> . BOOL
    (21) num_type -> . FLOAT
    (22) num_type -> . INTEGER
    (23) num_type -> . DOUBLE
    (45) list_structure -> . LSQUARE elements RSQUARE
    (46) map_structure -> . LBRACE key_value_pairs RBRACE

    $end            reduce using rule 1 (program -> statements .)
    VARIABLE        shift and go to state 6
    VOID            shift and go to state 12
    STRING          shift and go to state 13
    LIST            shift and go to state 14
    SET             shift and go to state 15
    MAP             shift and go to state 16
    STACK           shift and go to state 17
    QUEUE           shift and go to state 18
    TREE            shift and go to state 19
    GRAPH           shift and go to state 20
    BOOL            shift and go to state 21
    FLOAT           shift and go to state 22
    INTEGER         shift and go to state 23
    DOUBLE          shift and go to state 24
    LSQUARE         shift and go to state 25
    LBRACE          shift and go to state 26

    statement                      shift and go to state 27
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    type                           shift and go to state 7
    bool_type                      shift and go to state 8
    num_type                       shift and go to state 9
    list_structure                 shift and go to state 10
    map_structure                  shift and go to state 11

state 3

    (3) statements -> statement .

    VARIABLE        reduce using rule 3 (statements -> statement .)
    VOID            reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    LIST            reduce using rule 3 (statements -> statement .)
    SET             reduce using rule 3 (statements -> statement .)
    MAP             reduce using rule 3 (statements -> statement .)
    STACK           reduce using rule 3 (statements -> statement .)
    QUEUE           reduce using rule 3 (statements -> statement .)
    TREE            reduce using rule 3 (statements -> statement .)
    GRAPH           reduce using rule 3 (statements -> statement .)
    BOOL            reduce using rule 3 (statements -> statement .)
    FLOAT           reduce using rule 3 (statements -> statement .)
    INTEGER         reduce using rule 3 (statements -> statement .)
    DOUBLE          reduce using rule 3 (statements -> statement .)
    LSQUARE         reduce using rule 3 (statements -> statement .)
    LBRACE          reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> var_declaration .

    VARIABLE        reduce using rule 4 (statement -> var_declaration .)
    VOID            reduce using rule 4 (statement -> var_declaration .)
    STRING          reduce using rule 4 (statement -> var_declaration .)
    LIST            reduce using rule 4 (statement -> var_declaration .)
    SET             reduce using rule 4 (statement -> var_declaration .)
    MAP             reduce using rule 4 (statement -> var_declaration .)
    STACK           reduce using rule 4 (statement -> var_declaration .)
    QUEUE           reduce using rule 4 (statement -> var_declaration .)
    TREE            reduce using rule 4 (statement -> var_declaration .)
    GRAPH           reduce using rule 4 (statement -> var_declaration .)
    BOOL            reduce using rule 4 (statement -> var_declaration .)
    FLOAT           reduce using rule 4 (statement -> var_declaration .)
    INTEGER         reduce using rule 4 (statement -> var_declaration .)
    DOUBLE          reduce using rule 4 (statement -> var_declaration .)
    LSQUARE         reduce using rule 4 (statement -> var_declaration .)
    LBRACE          reduce using rule 4 (statement -> var_declaration .)
    $end            reduce using rule 4 (statement -> var_declaration .)


state 5

    (5) statement -> data_structure .

    VARIABLE        reduce using rule 5 (statement -> data_structure .)
    VOID            reduce using rule 5 (statement -> data_structure .)
    STRING          reduce using rule 5 (statement -> data_structure .)
    LIST            reduce using rule 5 (statement -> data_structure .)
    SET             reduce using rule 5 (statement -> data_structure .)
    MAP             reduce using rule 5 (statement -> data_structure .)
    STACK           reduce using rule 5 (statement -> data_structure .)
    QUEUE           reduce using rule 5 (statement -> data_structure .)
    TREE            reduce using rule 5 (statement -> data_structure .)
    GRAPH           reduce using rule 5 (statement -> data_structure .)
    BOOL            reduce using rule 5 (statement -> data_structure .)
    FLOAT           reduce using rule 5 (statement -> data_structure .)
    INTEGER         reduce using rule 5 (statement -> data_structure .)
    DOUBLE          reduce using rule 5 (statement -> data_structure .)
    LSQUARE         reduce using rule 5 (statement -> data_structure .)
    LBRACE          reduce using rule 5 (statement -> data_structure .)
    $end            reduce using rule 5 (statement -> data_structure .)


state 6

    (6) var_declaration -> VARIABLE . ASSIGN expression SEMICOLON
    (7) var_declaration -> VARIABLE . NULL_ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 28
    NULL_ASSIGN     shift and go to state 29


state 7

    (8) var_declaration -> type . VARIABLE ASSIGN expression SEMICOLON

    VARIABLE        shift and go to state 30


state 8

    (9) var_declaration -> bool_type . VARIABLE ASSIGN bool_expression SEMICOLON

    VARIABLE        shift and go to state 31


state 9

    (10) var_declaration -> num_type . VARIABLE ASSIGN num_expression SEMICOLON

    VARIABLE        shift and go to state 32


state 10

    (43) data_structure -> list_structure .

    VARIABLE        reduce using rule 43 (data_structure -> list_structure .)
    VOID            reduce using rule 43 (data_structure -> list_structure .)
    STRING          reduce using rule 43 (data_structure -> list_structure .)
    LIST            reduce using rule 43 (data_structure -> list_structure .)
    SET             reduce using rule 43 (data_structure -> list_structure .)
    MAP             reduce using rule 43 (data_structure -> list_structure .)
    STACK           reduce using rule 43 (data_structure -> list_structure .)
    QUEUE           reduce using rule 43 (data_structure -> list_structure .)
    TREE            reduce using rule 43 (data_structure -> list_structure .)
    GRAPH           reduce using rule 43 (data_structure -> list_structure .)
    BOOL            reduce using rule 43 (data_structure -> list_structure .)
    FLOAT           reduce using rule 43 (data_structure -> list_structure .)
    INTEGER         reduce using rule 43 (data_structure -> list_structure .)
    DOUBLE          reduce using rule 43 (data_structure -> list_structure .)
    LSQUARE         reduce using rule 43 (data_structure -> list_structure .)
    LBRACE          reduce using rule 43 (data_structure -> list_structure .)
    $end            reduce using rule 43 (data_structure -> list_structure .)


state 11

    (44) data_structure -> map_structure .

    VARIABLE        reduce using rule 44 (data_structure -> map_structure .)
    VOID            reduce using rule 44 (data_structure -> map_structure .)
    STRING          reduce using rule 44 (data_structure -> map_structure .)
    LIST            reduce using rule 44 (data_structure -> map_structure .)
    SET             reduce using rule 44 (data_structure -> map_structure .)
    MAP             reduce using rule 44 (data_structure -> map_structure .)
    STACK           reduce using rule 44 (data_structure -> map_structure .)
    QUEUE           reduce using rule 44 (data_structure -> map_structure .)
    TREE            reduce using rule 44 (data_structure -> map_structure .)
    GRAPH           reduce using rule 44 (data_structure -> map_structure .)
    BOOL            reduce using rule 44 (data_structure -> map_structure .)
    FLOAT           reduce using rule 44 (data_structure -> map_structure .)
    INTEGER         reduce using rule 44 (data_structure -> map_structure .)
    DOUBLE          reduce using rule 44 (data_structure -> map_structure .)
    LSQUARE         reduce using rule 44 (data_structure -> map_structure .)
    LBRACE          reduce using rule 44 (data_structure -> map_structure .)
    $end            reduce using rule 44 (data_structure -> map_structure .)


state 12

    (11) type -> VOID .

    VARIABLE        reduce using rule 11 (type -> VOID .)


state 13

    (12) type -> STRING .

    VARIABLE        reduce using rule 12 (type -> STRING .)


state 14

    (13) type -> LIST .

    VARIABLE        reduce using rule 13 (type -> LIST .)


state 15

    (14) type -> SET .

    VARIABLE        reduce using rule 14 (type -> SET .)


state 16

    (15) type -> MAP .

    VARIABLE        reduce using rule 15 (type -> MAP .)


state 17

    (16) type -> STACK .

    VARIABLE        reduce using rule 16 (type -> STACK .)


state 18

    (17) type -> QUEUE .

    VARIABLE        reduce using rule 17 (type -> QUEUE .)


state 19

    (18) type -> TREE .

    VARIABLE        reduce using rule 18 (type -> TREE .)


state 20

    (19) type -> GRAPH .

    VARIABLE        reduce using rule 19 (type -> GRAPH .)


state 21

    (20) bool_type -> BOOL .

    VARIABLE        reduce using rule 20 (bool_type -> BOOL .)


state 22

    (21) num_type -> FLOAT .

    VARIABLE        reduce using rule 21 (num_type -> FLOAT .)


state 23

    (22) num_type -> INTEGER .

    VARIABLE        reduce using rule 22 (num_type -> INTEGER .)


state 24

    (23) num_type -> DOUBLE .

    VARIABLE        reduce using rule 23 (num_type -> DOUBLE .)


state 25

    (45) list_structure -> LSQUARE . elements RSQUARE
    (47) elements -> . elements COMMA expression
    (48) elements -> . expression
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    elements                       shift and go to state 33
    expression                     shift and go to state 34
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 26

    (46) map_structure -> LBRACE . key_value_pairs RBRACE
    (49) key_value_pairs -> . key_value_pairs COMMA key_value
    (50) key_value_pairs -> . key_value
    (51) key_value -> . expression COLON expression
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    key_value_pairs                shift and go to state 45
    key_value                      shift and go to state 46
    expression                     shift and go to state 47
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 27

    (2) statements -> statements statement .

    VARIABLE        reduce using rule 2 (statements -> statements statement .)
    VOID            reduce using rule 2 (statements -> statements statement .)
    STRING          reduce using rule 2 (statements -> statements statement .)
    LIST            reduce using rule 2 (statements -> statements statement .)
    SET             reduce using rule 2 (statements -> statements statement .)
    MAP             reduce using rule 2 (statements -> statements statement .)
    STACK           reduce using rule 2 (statements -> statements statement .)
    QUEUE           reduce using rule 2 (statements -> statements statement .)
    TREE            reduce using rule 2 (statements -> statements statement .)
    GRAPH           reduce using rule 2 (statements -> statements statement .)
    BOOL            reduce using rule 2 (statements -> statements statement .)
    FLOAT           reduce using rule 2 (statements -> statements statement .)
    INTEGER         reduce using rule 2 (statements -> statements statement .)
    DOUBLE          reduce using rule 2 (statements -> statements statement .)
    LSQUARE         reduce using rule 2 (statements -> statements statement .)
    LBRACE          reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)


state 28

    (6) var_declaration -> VARIABLE ASSIGN . expression SEMICOLON
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    expression                     shift and go to state 48
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 29

    (7) var_declaration -> VARIABLE NULL_ASSIGN . expression SEMICOLON
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    expression                     shift and go to state 49
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 30

    (8) var_declaration -> type VARIABLE . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 50


state 31

    (9) var_declaration -> bool_type VARIABLE . ASSIGN bool_expression SEMICOLON

    ASSIGN          shift and go to state 51


state 32

    (10) var_declaration -> num_type VARIABLE . ASSIGN num_expression SEMICOLON

    ASSIGN          shift and go to state 52


state 33

    (45) list_structure -> LSQUARE elements . RSQUARE
    (47) elements -> elements . COMMA expression

    RSQUARE         shift and go to state 53
    COMMA           shift and go to state 54


state 34

    (48) elements -> expression .

    RSQUARE         reduce using rule 48 (elements -> expression .)
    COMMA           reduce using rule 48 (elements -> expression .)


state 35

    (24) expression -> bool_expression .
    (33) bool_expression -> bool_expression . AND bool_expression
    (34) bool_expression -> bool_expression . OR bool_expression

    RSQUARE         reduce using rule 24 (expression -> bool_expression .)
    COMMA           reduce using rule 24 (expression -> bool_expression .)
    COLON           reduce using rule 24 (expression -> bool_expression .)
    SEMICOLON       reduce using rule 24 (expression -> bool_expression .)
    RBRACE          reduce using rule 24 (expression -> bool_expression .)
    AND             shift and go to state 55
    OR              shift and go to state 56


state 36

    (25) expression -> num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

    RSQUARE         reduce using rule 25 (expression -> num_expression .)
    COMMA           reduce using rule 25 (expression -> num_expression .)
    COLON           reduce using rule 25 (expression -> num_expression .)
    SEMICOLON       reduce using rule 25 (expression -> num_expression .)
    RBRACE          reduce using rule 25 (expression -> num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62


state 37

    (26) expression -> VARIABLE .

    RSQUARE         reduce using rule 26 (expression -> VARIABLE .)
    COMMA           reduce using rule 26 (expression -> VARIABLE .)
    COLON           reduce using rule 26 (expression -> VARIABLE .)
    SEMICOLON       reduce using rule 26 (expression -> VARIABLE .)
    RBRACE          reduce using rule 26 (expression -> VARIABLE .)


state 38

    (27) bool_expression -> TRUE .

    AND             reduce using rule 27 (bool_expression -> TRUE .)
    OR              reduce using rule 27 (bool_expression -> TRUE .)
    RSQUARE         reduce using rule 27 (bool_expression -> TRUE .)
    COMMA           reduce using rule 27 (bool_expression -> TRUE .)
    COLON           reduce using rule 27 (bool_expression -> TRUE .)
    SEMICOLON       reduce using rule 27 (bool_expression -> TRUE .)
    RPAREN          reduce using rule 27 (bool_expression -> TRUE .)
    RBRACE          reduce using rule 27 (bool_expression -> TRUE .)


state 39

    (28) bool_expression -> FALSE .

    AND             reduce using rule 28 (bool_expression -> FALSE .)
    OR              reduce using rule 28 (bool_expression -> FALSE .)
    RSQUARE         reduce using rule 28 (bool_expression -> FALSE .)
    COMMA           reduce using rule 28 (bool_expression -> FALSE .)
    COLON           reduce using rule 28 (bool_expression -> FALSE .)
    SEMICOLON       reduce using rule 28 (bool_expression -> FALSE .)
    RPAREN          reduce using rule 28 (bool_expression -> FALSE .)
    RBRACE          reduce using rule 28 (bool_expression -> FALSE .)


state 40

    (32) bool_expression -> NEGATION . bool_expression
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 64

    bool_expression                shift and go to state 63

state 41

    (41) bool_expression -> LPAREN . bool_expression RPAREN
    (42) num_expression -> LPAREN . num_expression RPAREN
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    bool_expression                shift and go to state 65
    num_expression                 shift and go to state 66

state 42

    (29) num_expression -> NUMBER .

    PLUS            reduce using rule 29 (num_expression -> NUMBER .)
    MINUS           reduce using rule 29 (num_expression -> NUMBER .)
    TIMES           reduce using rule 29 (num_expression -> NUMBER .)
    DIVIDE          reduce using rule 29 (num_expression -> NUMBER .)
    INTEGER_DIVIDE  reduce using rule 29 (num_expression -> NUMBER .)
    MODULE          reduce using rule 29 (num_expression -> NUMBER .)
    RSQUARE         reduce using rule 29 (num_expression -> NUMBER .)
    COMMA           reduce using rule 29 (num_expression -> NUMBER .)
    COLON           reduce using rule 29 (num_expression -> NUMBER .)
    SEMICOLON       reduce using rule 29 (num_expression -> NUMBER .)
    RPAREN          reduce using rule 29 (num_expression -> NUMBER .)
    RBRACE          reduce using rule 29 (num_expression -> NUMBER .)


state 43

    (30) num_expression -> INTEGER .

    PLUS            reduce using rule 30 (num_expression -> INTEGER .)
    MINUS           reduce using rule 30 (num_expression -> INTEGER .)
    TIMES           reduce using rule 30 (num_expression -> INTEGER .)
    DIVIDE          reduce using rule 30 (num_expression -> INTEGER .)
    INTEGER_DIVIDE  reduce using rule 30 (num_expression -> INTEGER .)
    MODULE          reduce using rule 30 (num_expression -> INTEGER .)
    RSQUARE         reduce using rule 30 (num_expression -> INTEGER .)
    COMMA           reduce using rule 30 (num_expression -> INTEGER .)
    COLON           reduce using rule 30 (num_expression -> INTEGER .)
    SEMICOLON       reduce using rule 30 (num_expression -> INTEGER .)
    RPAREN          reduce using rule 30 (num_expression -> INTEGER .)
    RBRACE          reduce using rule 30 (num_expression -> INTEGER .)


state 44

    (31) num_expression -> FLOAT .

    PLUS            reduce using rule 31 (num_expression -> FLOAT .)
    MINUS           reduce using rule 31 (num_expression -> FLOAT .)
    TIMES           reduce using rule 31 (num_expression -> FLOAT .)
    DIVIDE          reduce using rule 31 (num_expression -> FLOAT .)
    INTEGER_DIVIDE  reduce using rule 31 (num_expression -> FLOAT .)
    MODULE          reduce using rule 31 (num_expression -> FLOAT .)
    RSQUARE         reduce using rule 31 (num_expression -> FLOAT .)
    COMMA           reduce using rule 31 (num_expression -> FLOAT .)
    COLON           reduce using rule 31 (num_expression -> FLOAT .)
    SEMICOLON       reduce using rule 31 (num_expression -> FLOAT .)
    RPAREN          reduce using rule 31 (num_expression -> FLOAT .)
    RBRACE          reduce using rule 31 (num_expression -> FLOAT .)


state 45

    (46) map_structure -> LBRACE key_value_pairs . RBRACE
    (49) key_value_pairs -> key_value_pairs . COMMA key_value

    RBRACE          shift and go to state 67
    COMMA           shift and go to state 68


state 46

    (50) key_value_pairs -> key_value .

    RBRACE          reduce using rule 50 (key_value_pairs -> key_value .)
    COMMA           reduce using rule 50 (key_value_pairs -> key_value .)


state 47

    (51) key_value -> expression . COLON expression

    COLON           shift and go to state 69


state 48

    (6) var_declaration -> VARIABLE ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 70


state 49

    (7) var_declaration -> VARIABLE NULL_ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 71


state 50

    (8) var_declaration -> type VARIABLE ASSIGN . expression SEMICOLON
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    expression                     shift and go to state 72
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 51

    (9) var_declaration -> bool_type VARIABLE ASSIGN . bool_expression SEMICOLON
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 64

    bool_expression                shift and go to state 73

state 52

    (10) var_declaration -> num_type VARIABLE ASSIGN . num_expression SEMICOLON
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 74

state 53

    (45) list_structure -> LSQUARE elements RSQUARE .

    VARIABLE        reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    VOID            reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    STRING          reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    LIST            reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    SET             reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    MAP             reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    STACK           reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    QUEUE           reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    TREE            reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    GRAPH           reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    BOOL            reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    FLOAT           reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    INTEGER         reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    DOUBLE          reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    LSQUARE         reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    LBRACE          reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)
    $end            reduce using rule 45 (list_structure -> LSQUARE elements RSQUARE .)


state 54

    (47) elements -> elements COMMA . expression
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    expression                     shift and go to state 76
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 55

    (33) bool_expression -> bool_expression AND . bool_expression
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 64

    bool_expression                shift and go to state 77

state 56

    (34) bool_expression -> bool_expression OR . bool_expression
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 64

    bool_expression                shift and go to state 78

state 57

    (35) num_expression -> num_expression PLUS . num_expression
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 79

state 58

    (36) num_expression -> num_expression MINUS . num_expression
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 80

state 59

    (37) num_expression -> num_expression TIMES . num_expression
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 81

state 60

    (38) num_expression -> num_expression DIVIDE . num_expression
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 82

state 61

    (39) num_expression -> num_expression INTEGER_DIVIDE . num_expression
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 83

state 62

    (40) num_expression -> num_expression MODULE . num_expression
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 84

state 63

    (32) bool_expression -> NEGATION bool_expression .
    (33) bool_expression -> bool_expression . AND bool_expression
    (34) bool_expression -> bool_expression . OR bool_expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RSQUARE         reduce using rule 32 (bool_expression -> NEGATION bool_expression .)
    COMMA           reduce using rule 32 (bool_expression -> NEGATION bool_expression .)
    COLON           reduce using rule 32 (bool_expression -> NEGATION bool_expression .)
    SEMICOLON       reduce using rule 32 (bool_expression -> NEGATION bool_expression .)
    RPAREN          reduce using rule 32 (bool_expression -> NEGATION bool_expression .)
    RBRACE          reduce using rule 32 (bool_expression -> NEGATION bool_expression .)
    AND             shift and go to state 55
    OR              shift and go to state 56

  ! AND             [ reduce using rule 32 (bool_expression -> NEGATION bool_expression .) ]
  ! OR              [ reduce using rule 32 (bool_expression -> NEGATION bool_expression .) ]


state 64

    (41) bool_expression -> LPAREN . bool_expression RPAREN
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 64

    bool_expression                shift and go to state 65

state 65

    (41) bool_expression -> LPAREN bool_expression . RPAREN
    (33) bool_expression -> bool_expression . AND bool_expression
    (34) bool_expression -> bool_expression . OR bool_expression

    RPAREN          shift and go to state 85
    AND             shift and go to state 55
    OR              shift and go to state 56


state 66

    (42) num_expression -> LPAREN num_expression . RPAREN
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62


state 67

    (46) map_structure -> LBRACE key_value_pairs RBRACE .

    VARIABLE        reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    VOID            reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    STRING          reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    LIST            reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    SET             reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    MAP             reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    STACK           reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    QUEUE           reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    TREE            reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    GRAPH           reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    BOOL            reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    FLOAT           reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    INTEGER         reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    DOUBLE          reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    LSQUARE         reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    LBRACE          reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)
    $end            reduce using rule 46 (map_structure -> LBRACE key_value_pairs RBRACE .)


state 68

    (49) key_value_pairs -> key_value_pairs COMMA . key_value
    (51) key_value -> . expression COLON expression
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    key_value                      shift and go to state 87
    expression                     shift and go to state 47
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 69

    (51) key_value -> expression COLON . expression
    (24) expression -> . bool_expression
    (25) expression -> . num_expression
    (26) expression -> . VARIABLE
    (27) bool_expression -> . TRUE
    (28) bool_expression -> . FALSE
    (32) bool_expression -> . NEGATION bool_expression
    (33) bool_expression -> . bool_expression AND bool_expression
    (34) bool_expression -> . bool_expression OR bool_expression
    (41) bool_expression -> . LPAREN bool_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 37
    TRUE            shift and go to state 38
    FALSE           shift and go to state 39
    NEGATION        shift and go to state 40
    LPAREN          shift and go to state 41
    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44

    expression                     shift and go to state 88
    bool_expression                shift and go to state 35
    num_expression                 shift and go to state 36

state 70

    (6) var_declaration -> VARIABLE ASSIGN expression SEMICOLON .

    VARIABLE        reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    SET             reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    STACK           reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    QUEUE           reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    TREE            reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    GRAPH           reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    $end            reduce using rule 6 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)


state 71

    (7) var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .

    VARIABLE        reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    SET             reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    STACK           reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    QUEUE           reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    TREE            reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    GRAPH           reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    $end            reduce using rule 7 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)


state 72

    (8) var_declaration -> type VARIABLE ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 89


state 73

    (9) var_declaration -> bool_type VARIABLE ASSIGN bool_expression . SEMICOLON
    (33) bool_expression -> bool_expression . AND bool_expression
    (34) bool_expression -> bool_expression . OR bool_expression

    SEMICOLON       shift and go to state 90
    AND             shift and go to state 55
    OR              shift and go to state 56


state 74

    (10) var_declaration -> num_type VARIABLE ASSIGN num_expression . SEMICOLON
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

    SEMICOLON       shift and go to state 91
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62


state 75

    (42) num_expression -> LPAREN . num_expression RPAREN
    (29) num_expression -> . NUMBER
    (30) num_expression -> . INTEGER
    (31) num_expression -> . FLOAT
    (35) num_expression -> . num_expression PLUS num_expression
    (36) num_expression -> . num_expression MINUS num_expression
    (37) num_expression -> . num_expression TIMES num_expression
    (38) num_expression -> . num_expression DIVIDE num_expression
    (39) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (40) num_expression -> . num_expression MODULE num_expression
    (42) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 42
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    LPAREN          shift and go to state 75

    num_expression                 shift and go to state 66

state 76

    (47) elements -> elements COMMA expression .

    RSQUARE         reduce using rule 47 (elements -> elements COMMA expression .)
    COMMA           reduce using rule 47 (elements -> elements COMMA expression .)


state 77

    (33) bool_expression -> bool_expression AND bool_expression .
    (33) bool_expression -> bool_expression . AND bool_expression
    (34) bool_expression -> bool_expression . OR bool_expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RSQUARE         reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .)
    COMMA           reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .)
    COLON           reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .)
    SEMICOLON       reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .)
    RPAREN          reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .)
    RBRACE          reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .)
    AND             shift and go to state 55
    OR              shift and go to state 56

  ! AND             [ reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .) ]
  ! OR              [ reduce using rule 33 (bool_expression -> bool_expression AND bool_expression .) ]


state 78

    (34) bool_expression -> bool_expression OR bool_expression .
    (33) bool_expression -> bool_expression . AND bool_expression
    (34) bool_expression -> bool_expression . OR bool_expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RSQUARE         reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .)
    COMMA           reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .)
    COLON           reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .)
    SEMICOLON       reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .)
    RPAREN          reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .)
    RBRACE          reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .)
    AND             shift and go to state 55
    OR              shift and go to state 56

  ! AND             [ reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .) ]
  ! OR              [ reduce using rule 34 (bool_expression -> bool_expression OR bool_expression .) ]


state 79

    (35) num_expression -> num_expression PLUS num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 35 (num_expression -> num_expression PLUS num_expression .)
    COMMA           reduce using rule 35 (num_expression -> num_expression PLUS num_expression .)
    COLON           reduce using rule 35 (num_expression -> num_expression PLUS num_expression .)
    SEMICOLON       reduce using rule 35 (num_expression -> num_expression PLUS num_expression .)
    RPAREN          reduce using rule 35 (num_expression -> num_expression PLUS num_expression .)
    RBRACE          reduce using rule 35 (num_expression -> num_expression PLUS num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62

  ! PLUS            [ reduce using rule 35 (num_expression -> num_expression PLUS num_expression .) ]
  ! MINUS           [ reduce using rule 35 (num_expression -> num_expression PLUS num_expression .) ]
  ! TIMES           [ reduce using rule 35 (num_expression -> num_expression PLUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 35 (num_expression -> num_expression PLUS num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 35 (num_expression -> num_expression PLUS num_expression .) ]
  ! MODULE          [ reduce using rule 35 (num_expression -> num_expression PLUS num_expression .) ]


state 80

    (36) num_expression -> num_expression MINUS num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 36 (num_expression -> num_expression MINUS num_expression .)
    COMMA           reduce using rule 36 (num_expression -> num_expression MINUS num_expression .)
    COLON           reduce using rule 36 (num_expression -> num_expression MINUS num_expression .)
    SEMICOLON       reduce using rule 36 (num_expression -> num_expression MINUS num_expression .)
    RPAREN          reduce using rule 36 (num_expression -> num_expression MINUS num_expression .)
    RBRACE          reduce using rule 36 (num_expression -> num_expression MINUS num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62

  ! PLUS            [ reduce using rule 36 (num_expression -> num_expression MINUS num_expression .) ]
  ! MINUS           [ reduce using rule 36 (num_expression -> num_expression MINUS num_expression .) ]
  ! TIMES           [ reduce using rule 36 (num_expression -> num_expression MINUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 36 (num_expression -> num_expression MINUS num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 36 (num_expression -> num_expression MINUS num_expression .) ]
  ! MODULE          [ reduce using rule 36 (num_expression -> num_expression MINUS num_expression .) ]


state 81

    (37) num_expression -> num_expression TIMES num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 37 (num_expression -> num_expression TIMES num_expression .)
    COMMA           reduce using rule 37 (num_expression -> num_expression TIMES num_expression .)
    COLON           reduce using rule 37 (num_expression -> num_expression TIMES num_expression .)
    SEMICOLON       reduce using rule 37 (num_expression -> num_expression TIMES num_expression .)
    RPAREN          reduce using rule 37 (num_expression -> num_expression TIMES num_expression .)
    RBRACE          reduce using rule 37 (num_expression -> num_expression TIMES num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62

  ! PLUS            [ reduce using rule 37 (num_expression -> num_expression TIMES num_expression .) ]
  ! MINUS           [ reduce using rule 37 (num_expression -> num_expression TIMES num_expression .) ]
  ! TIMES           [ reduce using rule 37 (num_expression -> num_expression TIMES num_expression .) ]
  ! DIVIDE          [ reduce using rule 37 (num_expression -> num_expression TIMES num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 37 (num_expression -> num_expression TIMES num_expression .) ]
  ! MODULE          [ reduce using rule 37 (num_expression -> num_expression TIMES num_expression .) ]


state 82

    (38) num_expression -> num_expression DIVIDE num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .)
    COMMA           reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .)
    COLON           reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .)
    SEMICOLON       reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .)
    RPAREN          reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .)
    RBRACE          reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62

  ! PLUS            [ reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! MINUS           [ reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! TIMES           [ reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! DIVIDE          [ reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! MODULE          [ reduce using rule 38 (num_expression -> num_expression DIVIDE num_expression .) ]


state 83

    (39) num_expression -> num_expression INTEGER_DIVIDE num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    COMMA           reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    COLON           reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    SEMICOLON       reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    RPAREN          reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    RBRACE          reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62

  ! PLUS            [ reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! MINUS           [ reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! TIMES           [ reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! DIVIDE          [ reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! MODULE          [ reduce using rule 39 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]


state 84

    (40) num_expression -> num_expression MODULE num_expression .
    (35) num_expression -> num_expression . PLUS num_expression
    (36) num_expression -> num_expression . MINUS num_expression
    (37) num_expression -> num_expression . TIMES num_expression
    (38) num_expression -> num_expression . DIVIDE num_expression
    (39) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (40) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 40 (num_expression -> num_expression MODULE num_expression .)
    COMMA           reduce using rule 40 (num_expression -> num_expression MODULE num_expression .)
    COLON           reduce using rule 40 (num_expression -> num_expression MODULE num_expression .)
    SEMICOLON       reduce using rule 40 (num_expression -> num_expression MODULE num_expression .)
    RPAREN          reduce using rule 40 (num_expression -> num_expression MODULE num_expression .)
    RBRACE          reduce using rule 40 (num_expression -> num_expression MODULE num_expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    INTEGER_DIVIDE  shift and go to state 61
    MODULE          shift and go to state 62

  ! PLUS            [ reduce using rule 40 (num_expression -> num_expression MODULE num_expression .) ]
  ! MINUS           [ reduce using rule 40 (num_expression -> num_expression MODULE num_expression .) ]
  ! TIMES           [ reduce using rule 40 (num_expression -> num_expression MODULE num_expression .) ]
  ! DIVIDE          [ reduce using rule 40 (num_expression -> num_expression MODULE num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 40 (num_expression -> num_expression MODULE num_expression .) ]
  ! MODULE          [ reduce using rule 40 (num_expression -> num_expression MODULE num_expression .) ]


state 85

    (41) bool_expression -> LPAREN bool_expression RPAREN .

    AND             reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    OR              reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    RSQUARE         reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    COMMA           reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    COLON           reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    SEMICOLON       reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    RPAREN          reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)
    RBRACE          reduce using rule 41 (bool_expression -> LPAREN bool_expression RPAREN .)


state 86

    (42) num_expression -> LPAREN num_expression RPAREN .

    PLUS            reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    MINUS           reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    TIMES           reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    DIVIDE          reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    INTEGER_DIVIDE  reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    MODULE          reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    RSQUARE         reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    COMMA           reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    COLON           reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    SEMICOLON       reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    RPAREN          reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)
    RBRACE          reduce using rule 42 (num_expression -> LPAREN num_expression RPAREN .)


state 87

    (49) key_value_pairs -> key_value_pairs COMMA key_value .

    RBRACE          reduce using rule 49 (key_value_pairs -> key_value_pairs COMMA key_value .)
    COMMA           reduce using rule 49 (key_value_pairs -> key_value_pairs COMMA key_value .)


state 88

    (51) key_value -> expression COLON expression .

    RBRACE          reduce using rule 51 (key_value -> expression COLON expression .)
    COMMA           reduce using rule 51 (key_value -> expression COLON expression .)


state 89

    (8) var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .

    VARIABLE        reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    SET             reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    STACK           reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    QUEUE           reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    TREE            reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    GRAPH           reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    $end            reduce using rule 8 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)


state 90

    (9) var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .

    VARIABLE        reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    VOID            reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    STRING          reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    LIST            reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    SET             reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    MAP             reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    STACK           reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    QUEUE           reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    TREE            reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    GRAPH           reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    BOOL            reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    FLOAT           reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    INTEGER         reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    DOUBLE          reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    LSQUARE         reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    LBRACE          reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    $end            reduce using rule 9 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)


state 91

    (10) var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .

    VARIABLE        reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    VOID            reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    STRING          reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    LIST            reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    SET             reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    MAP             reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    STACK           reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    QUEUE           reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    TREE            reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    GRAPH           reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    BOOL            reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    FLOAT           reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    INTEGER         reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    DOUBLE          reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    LSQUARE         reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    LBRACE          reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    $end            reduce using rule 10 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 63 resolved as shift
WARNING: shift/reduce conflict for OR in state 63 resolved as shift
WARNING: shift/reduce conflict for AND in state 77 resolved as shift
WARNING: shift/reduce conflict for OR in state 77 resolved as shift
WARNING: shift/reduce conflict for AND in state 78 resolved as shift
WARNING: shift/reduce conflict for OR in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 82 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 82 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 82 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 82 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 84 resolved as shift
