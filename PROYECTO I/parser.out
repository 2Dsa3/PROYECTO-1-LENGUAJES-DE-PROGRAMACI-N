Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    BLOCK_COMMENT
    CLASS
    COMPOSED_ASSIGN
    CONST
    CONTINUE
    DECREMENT
    DO
    DOC_COMMENT
    DOT
    DYNAMIC
    ELSE
    EXTENDS
    FINAL
    FOR
    HASH
    IMPLEMENTS
    INCREMENT
    INTERFACE
    IS
    IS_NOT
    LINE_COMMENT
    NULL
    OBJECT
    PRINT
    PRIVATE
    PROTECTED
    PUBLIC
    STRING_LITERAL
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> var_declaration
Rule 5     statement -> data_structure
Rule 6     statement -> control_structure
Rule 7     var_declaration -> VARIABLE ASSIGN expression SEMICOLON
Rule 8     var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON
Rule 9     var_declaration -> type VARIABLE ASSIGN expression SEMICOLON
Rule 10    var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON
Rule 11    var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON
Rule 12    type -> VOID
Rule 13    type -> STRING
Rule 14    type -> LIST
Rule 15    type -> SET
Rule 16    type -> MAP
Rule 17    type -> STACK
Rule 18    type -> QUEUE
Rule 19    type -> TREE
Rule 20    type -> GRAPH
Rule 21    bool_type -> BOOL
Rule 22    num_type -> FLOAT
Rule 23    num_type -> INTEGER
Rule 24    num_type -> DOUBLE
Rule 25    expression -> bool_expression
Rule 26    expression -> num_expression
Rule 27    expression -> VARIABLE
Rule 28    bool_expression -> TRUE
Rule 29    bool_expression -> FALSE
Rule 30    num_expression -> NUMBER
Rule 31    num_expression -> INTEGER
Rule 32    num_expression -> FLOAT
Rule 33    bool_expression -> NEGATION bool_expression
Rule 34    bool_expression -> bool_expression AND bool_expression
Rule 35    bool_expression -> bool_expression OR bool_expression
Rule 36    num_expression -> num_expression PLUS num_expression
Rule 37    num_expression -> num_expression MINUS num_expression
Rule 38    num_expression -> num_expression TIMES num_expression
Rule 39    num_expression -> num_expression DIVIDE num_expression
Rule 40    num_expression -> num_expression INTEGER_DIVIDE num_expression
Rule 41    num_expression -> num_expression MODULE num_expression
Rule 42    bool_expression -> LPAREN bool_expression RPAREN
Rule 43    num_expression -> LPAREN num_expression RPAREN
Rule 44    data_structure -> list_structure
Rule 45    data_structure -> map_structure
Rule 46    list_structure -> LSQUARE elements RSQUARE
Rule 47    map_structure -> LBRACE key_value_pairs RBRACE
Rule 48    elements -> elements COMMA expression
Rule 49    elements -> expression
Rule 50    key_value_pairs -> key_value_pairs COMMA key_value
Rule 51    key_value_pairs -> key_value
Rule 52    key_value -> expression COLON expression
Rule 53    control_structure -> if_structure
Rule 54    control_structure -> switch_structure
Rule 55    if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE
Rule 56    switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE
Rule 57    condition -> expression GREATER_THAN expression
Rule 58    condition -> expression LESS_THAN expression
Rule 59    condition -> expression GREATER_EQ expression
Rule 60    condition -> expression LESS_EQ expression
Rule 61    condition -> expression EQUALS expression
Rule 62    condition -> expression NOT_EQUALS expression
Rule 63    cases -> cases case
Rule 64    cases -> case
Rule 65    case -> CASE NUMBER COLON statement BREAK SEMICOLON
Rule 66    default -> DEFAULT COLON statement
Rule 67    default -> empty
Rule 68    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 34
AS                   : 
ASSIGN               : 7 9 10 11
BLOCK_COMMENT        : 
BOOL                 : 21
BREAK                : 65
CASE                 : 65
CLASS                : 
COLON                : 52 65 66
COMMA                : 48 50
COMPOSED_ASSIGN      : 
CONST                : 
CONTINUE             : 
DECREMENT            : 
DEFAULT              : 66
DIVIDE               : 39
DO                   : 
DOC_COMMENT          : 
DOT                  : 
DOUBLE               : 24
DYNAMIC              : 
ELSE                 : 
EQUALS               : 61
EXTENDS              : 
FALSE                : 29
FINAL                : 
FLOAT                : 22 32
FOR                  : 
GRAPH                : 20
GREATER_EQ           : 59
GREATER_THAN         : 57
HASH                 : 
IF                   : 55
IMPLEMENTS           : 
INCREMENT            : 
INTEGER              : 23 31
INTEGER_DIVIDE       : 40
INTERFACE            : 
IS                   : 
IS_NOT               : 
LBRACE               : 47 55 56
LESS_EQ              : 60
LESS_THAN            : 58
LINE_COMMENT         : 
LIST                 : 14
LPAREN               : 42 43 55 56
LSQUARE              : 46
MAP                  : 16
MINUS                : 37
MODULE               : 41
NEGATION             : 33
NOT_EQUALS           : 62
NULL                 : 
NULL_ASSIGN          : 8
NUMBER               : 30 65
OBJECT               : 
OR                   : 35
PLUS                 : 36
PRINT                : 
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUEUE                : 18
RBRACE               : 47 55 56
RPAREN               : 42 43 55 56
RSQUARE              : 46
SEMICOLON            : 7 8 9 10 11 65
SET                  : 15
STACK                : 17
STRING               : 13
STRING_LITERAL       : 
SWITCH               : 56
TIMES                : 38
TREE                 : 19
TRUE                 : 28
VARIABLE             : 7 8 9 10 11 27
VOID                 : 12
WHILE                : 
error                : 

Nonterminals, with rules where they appear

bool_expression      : 10 25 33 34 34 35 35 42
bool_type            : 10
case                 : 63 64
cases                : 56 63
condition            : 55
control_structure    : 6
data_structure       : 5
default              : 56
elements             : 46 48
empty                : 67
expression           : 7 8 9 48 49 52 52 56 57 57 58 58 59 59 60 60 61 61 62 62
if_structure         : 53
key_value            : 50 51
key_value_pairs      : 47 50
list_structure       : 44
map_structure        : 45
num_expression       : 11 26 36 36 37 37 38 38 39 39 40 40 41 41 43
num_type             : 11
program              : 0
statement            : 2 3 55 65 66
statements           : 1 2
switch_structure     : 54
type                 : 9
var_declaration      : 4

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) statement -> . control_structure
    (7) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (8) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (9) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (10) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (11) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (44) data_structure -> . list_structure
    (45) data_structure -> . map_structure
    (53) control_structure -> . if_structure
    (54) control_structure -> . switch_structure
    (12) type -> . VOID
    (13) type -> . STRING
    (14) type -> . LIST
    (15) type -> . SET
    (16) type -> . MAP
    (17) type -> . STACK
    (18) type -> . QUEUE
    (19) type -> . TREE
    (20) type -> . GRAPH
    (21) bool_type -> . BOOL
    (22) num_type -> . FLOAT
    (23) num_type -> . INTEGER
    (24) num_type -> . DOUBLE
    (46) list_structure -> . LSQUARE elements RSQUARE
    (47) map_structure -> . LBRACE key_value_pairs RBRACE
    (55) if_structure -> . IF LPAREN condition RPAREN LBRACE statement RBRACE
    (56) switch_structure -> . SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE

    VARIABLE        shift and go to state 7
    VOID            shift and go to state 15
    STRING          shift and go to state 16
    LIST            shift and go to state 17
    SET             shift and go to state 18
    MAP             shift and go to state 19
    STACK           shift and go to state 20
    QUEUE           shift and go to state 21
    TREE            shift and go to state 22
    GRAPH           shift and go to state 23
    BOOL            shift and go to state 24
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 26
    DOUBLE          shift and go to state 27
    LSQUARE         shift and go to state 28
    LBRACE          shift and go to state 29
    IF              shift and go to state 30
    SWITCH          shift and go to state 31

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    control_structure              shift and go to state 6
    type                           shift and go to state 8
    bool_type                      shift and go to state 9
    num_type                       shift and go to state 10
    list_structure                 shift and go to state 11
    map_structure                  shift and go to state 12
    if_structure                   shift and go to state 13
    switch_structure               shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) statement -> . control_structure
    (7) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (8) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (9) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (10) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (11) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (44) data_structure -> . list_structure
    (45) data_structure -> . map_structure
    (53) control_structure -> . if_structure
    (54) control_structure -> . switch_structure
    (12) type -> . VOID
    (13) type -> . STRING
    (14) type -> . LIST
    (15) type -> . SET
    (16) type -> . MAP
    (17) type -> . STACK
    (18) type -> . QUEUE
    (19) type -> . TREE
    (20) type -> . GRAPH
    (21) bool_type -> . BOOL
    (22) num_type -> . FLOAT
    (23) num_type -> . INTEGER
    (24) num_type -> . DOUBLE
    (46) list_structure -> . LSQUARE elements RSQUARE
    (47) map_structure -> . LBRACE key_value_pairs RBRACE
    (55) if_structure -> . IF LPAREN condition RPAREN LBRACE statement RBRACE
    (56) switch_structure -> . SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE

    $end            reduce using rule 1 (program -> statements .)
    VARIABLE        shift and go to state 7
    VOID            shift and go to state 15
    STRING          shift and go to state 16
    LIST            shift and go to state 17
    SET             shift and go to state 18
    MAP             shift and go to state 19
    STACK           shift and go to state 20
    QUEUE           shift and go to state 21
    TREE            shift and go to state 22
    GRAPH           shift and go to state 23
    BOOL            shift and go to state 24
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 26
    DOUBLE          shift and go to state 27
    LSQUARE         shift and go to state 28
    LBRACE          shift and go to state 29
    IF              shift and go to state 30
    SWITCH          shift and go to state 31

    statement                      shift and go to state 32
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    control_structure              shift and go to state 6
    type                           shift and go to state 8
    bool_type                      shift and go to state 9
    num_type                       shift and go to state 10
    list_structure                 shift and go to state 11
    map_structure                  shift and go to state 12
    if_structure                   shift and go to state 13
    switch_structure               shift and go to state 14

state 3

    (3) statements -> statement .

    VARIABLE        reduce using rule 3 (statements -> statement .)
    VOID            reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    LIST            reduce using rule 3 (statements -> statement .)
    SET             reduce using rule 3 (statements -> statement .)
    MAP             reduce using rule 3 (statements -> statement .)
    STACK           reduce using rule 3 (statements -> statement .)
    QUEUE           reduce using rule 3 (statements -> statement .)
    TREE            reduce using rule 3 (statements -> statement .)
    GRAPH           reduce using rule 3 (statements -> statement .)
    BOOL            reduce using rule 3 (statements -> statement .)
    FLOAT           reduce using rule 3 (statements -> statement .)
    INTEGER         reduce using rule 3 (statements -> statement .)
    DOUBLE          reduce using rule 3 (statements -> statement .)
    LSQUARE         reduce using rule 3 (statements -> statement .)
    LBRACE          reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    SWITCH          reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> var_declaration .

    VARIABLE        reduce using rule 4 (statement -> var_declaration .)
    VOID            reduce using rule 4 (statement -> var_declaration .)
    STRING          reduce using rule 4 (statement -> var_declaration .)
    LIST            reduce using rule 4 (statement -> var_declaration .)
    SET             reduce using rule 4 (statement -> var_declaration .)
    MAP             reduce using rule 4 (statement -> var_declaration .)
    STACK           reduce using rule 4 (statement -> var_declaration .)
    QUEUE           reduce using rule 4 (statement -> var_declaration .)
    TREE            reduce using rule 4 (statement -> var_declaration .)
    GRAPH           reduce using rule 4 (statement -> var_declaration .)
    BOOL            reduce using rule 4 (statement -> var_declaration .)
    FLOAT           reduce using rule 4 (statement -> var_declaration .)
    INTEGER         reduce using rule 4 (statement -> var_declaration .)
    DOUBLE          reduce using rule 4 (statement -> var_declaration .)
    LSQUARE         reduce using rule 4 (statement -> var_declaration .)
    LBRACE          reduce using rule 4 (statement -> var_declaration .)
    IF              reduce using rule 4 (statement -> var_declaration .)
    SWITCH          reduce using rule 4 (statement -> var_declaration .)
    $end            reduce using rule 4 (statement -> var_declaration .)
    RBRACE          reduce using rule 4 (statement -> var_declaration .)
    BREAK           reduce using rule 4 (statement -> var_declaration .)


state 5

    (5) statement -> data_structure .

    VARIABLE        reduce using rule 5 (statement -> data_structure .)
    VOID            reduce using rule 5 (statement -> data_structure .)
    STRING          reduce using rule 5 (statement -> data_structure .)
    LIST            reduce using rule 5 (statement -> data_structure .)
    SET             reduce using rule 5 (statement -> data_structure .)
    MAP             reduce using rule 5 (statement -> data_structure .)
    STACK           reduce using rule 5 (statement -> data_structure .)
    QUEUE           reduce using rule 5 (statement -> data_structure .)
    TREE            reduce using rule 5 (statement -> data_structure .)
    GRAPH           reduce using rule 5 (statement -> data_structure .)
    BOOL            reduce using rule 5 (statement -> data_structure .)
    FLOAT           reduce using rule 5 (statement -> data_structure .)
    INTEGER         reduce using rule 5 (statement -> data_structure .)
    DOUBLE          reduce using rule 5 (statement -> data_structure .)
    LSQUARE         reduce using rule 5 (statement -> data_structure .)
    LBRACE          reduce using rule 5 (statement -> data_structure .)
    IF              reduce using rule 5 (statement -> data_structure .)
    SWITCH          reduce using rule 5 (statement -> data_structure .)
    $end            reduce using rule 5 (statement -> data_structure .)
    RBRACE          reduce using rule 5 (statement -> data_structure .)
    BREAK           reduce using rule 5 (statement -> data_structure .)


state 6

    (6) statement -> control_structure .

    VARIABLE        reduce using rule 6 (statement -> control_structure .)
    VOID            reduce using rule 6 (statement -> control_structure .)
    STRING          reduce using rule 6 (statement -> control_structure .)
    LIST            reduce using rule 6 (statement -> control_structure .)
    SET             reduce using rule 6 (statement -> control_structure .)
    MAP             reduce using rule 6 (statement -> control_structure .)
    STACK           reduce using rule 6 (statement -> control_structure .)
    QUEUE           reduce using rule 6 (statement -> control_structure .)
    TREE            reduce using rule 6 (statement -> control_structure .)
    GRAPH           reduce using rule 6 (statement -> control_structure .)
    BOOL            reduce using rule 6 (statement -> control_structure .)
    FLOAT           reduce using rule 6 (statement -> control_structure .)
    INTEGER         reduce using rule 6 (statement -> control_structure .)
    DOUBLE          reduce using rule 6 (statement -> control_structure .)
    LSQUARE         reduce using rule 6 (statement -> control_structure .)
    LBRACE          reduce using rule 6 (statement -> control_structure .)
    IF              reduce using rule 6 (statement -> control_structure .)
    SWITCH          reduce using rule 6 (statement -> control_structure .)
    $end            reduce using rule 6 (statement -> control_structure .)
    RBRACE          reduce using rule 6 (statement -> control_structure .)
    BREAK           reduce using rule 6 (statement -> control_structure .)


state 7

    (7) var_declaration -> VARIABLE . ASSIGN expression SEMICOLON
    (8) var_declaration -> VARIABLE . NULL_ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 33
    NULL_ASSIGN     shift and go to state 34


state 8

    (9) var_declaration -> type . VARIABLE ASSIGN expression SEMICOLON

    VARIABLE        shift and go to state 35


state 9

    (10) var_declaration -> bool_type . VARIABLE ASSIGN bool_expression SEMICOLON

    VARIABLE        shift and go to state 36


state 10

    (11) var_declaration -> num_type . VARIABLE ASSIGN num_expression SEMICOLON

    VARIABLE        shift and go to state 37


state 11

    (44) data_structure -> list_structure .

    VARIABLE        reduce using rule 44 (data_structure -> list_structure .)
    VOID            reduce using rule 44 (data_structure -> list_structure .)
    STRING          reduce using rule 44 (data_structure -> list_structure .)
    LIST            reduce using rule 44 (data_structure -> list_structure .)
    SET             reduce using rule 44 (data_structure -> list_structure .)
    MAP             reduce using rule 44 (data_structure -> list_structure .)
    STACK           reduce using rule 44 (data_structure -> list_structure .)
    QUEUE           reduce using rule 44 (data_structure -> list_structure .)
    TREE            reduce using rule 44 (data_structure -> list_structure .)
    GRAPH           reduce using rule 44 (data_structure -> list_structure .)
    BOOL            reduce using rule 44 (data_structure -> list_structure .)
    FLOAT           reduce using rule 44 (data_structure -> list_structure .)
    INTEGER         reduce using rule 44 (data_structure -> list_structure .)
    DOUBLE          reduce using rule 44 (data_structure -> list_structure .)
    LSQUARE         reduce using rule 44 (data_structure -> list_structure .)
    LBRACE          reduce using rule 44 (data_structure -> list_structure .)
    IF              reduce using rule 44 (data_structure -> list_structure .)
    SWITCH          reduce using rule 44 (data_structure -> list_structure .)
    $end            reduce using rule 44 (data_structure -> list_structure .)
    RBRACE          reduce using rule 44 (data_structure -> list_structure .)
    BREAK           reduce using rule 44 (data_structure -> list_structure .)


state 12

    (45) data_structure -> map_structure .

    VARIABLE        reduce using rule 45 (data_structure -> map_structure .)
    VOID            reduce using rule 45 (data_structure -> map_structure .)
    STRING          reduce using rule 45 (data_structure -> map_structure .)
    LIST            reduce using rule 45 (data_structure -> map_structure .)
    SET             reduce using rule 45 (data_structure -> map_structure .)
    MAP             reduce using rule 45 (data_structure -> map_structure .)
    STACK           reduce using rule 45 (data_structure -> map_structure .)
    QUEUE           reduce using rule 45 (data_structure -> map_structure .)
    TREE            reduce using rule 45 (data_structure -> map_structure .)
    GRAPH           reduce using rule 45 (data_structure -> map_structure .)
    BOOL            reduce using rule 45 (data_structure -> map_structure .)
    FLOAT           reduce using rule 45 (data_structure -> map_structure .)
    INTEGER         reduce using rule 45 (data_structure -> map_structure .)
    DOUBLE          reduce using rule 45 (data_structure -> map_structure .)
    LSQUARE         reduce using rule 45 (data_structure -> map_structure .)
    LBRACE          reduce using rule 45 (data_structure -> map_structure .)
    IF              reduce using rule 45 (data_structure -> map_structure .)
    SWITCH          reduce using rule 45 (data_structure -> map_structure .)
    $end            reduce using rule 45 (data_structure -> map_structure .)
    RBRACE          reduce using rule 45 (data_structure -> map_structure .)
    BREAK           reduce using rule 45 (data_structure -> map_structure .)


state 13

    (53) control_structure -> if_structure .

    VARIABLE        reduce using rule 53 (control_structure -> if_structure .)
    VOID            reduce using rule 53 (control_structure -> if_structure .)
    STRING          reduce using rule 53 (control_structure -> if_structure .)
    LIST            reduce using rule 53 (control_structure -> if_structure .)
    SET             reduce using rule 53 (control_structure -> if_structure .)
    MAP             reduce using rule 53 (control_structure -> if_structure .)
    STACK           reduce using rule 53 (control_structure -> if_structure .)
    QUEUE           reduce using rule 53 (control_structure -> if_structure .)
    TREE            reduce using rule 53 (control_structure -> if_structure .)
    GRAPH           reduce using rule 53 (control_structure -> if_structure .)
    BOOL            reduce using rule 53 (control_structure -> if_structure .)
    FLOAT           reduce using rule 53 (control_structure -> if_structure .)
    INTEGER         reduce using rule 53 (control_structure -> if_structure .)
    DOUBLE          reduce using rule 53 (control_structure -> if_structure .)
    LSQUARE         reduce using rule 53 (control_structure -> if_structure .)
    LBRACE          reduce using rule 53 (control_structure -> if_structure .)
    IF              reduce using rule 53 (control_structure -> if_structure .)
    SWITCH          reduce using rule 53 (control_structure -> if_structure .)
    $end            reduce using rule 53 (control_structure -> if_structure .)
    RBRACE          reduce using rule 53 (control_structure -> if_structure .)
    BREAK           reduce using rule 53 (control_structure -> if_structure .)


state 14

    (54) control_structure -> switch_structure .

    VARIABLE        reduce using rule 54 (control_structure -> switch_structure .)
    VOID            reduce using rule 54 (control_structure -> switch_structure .)
    STRING          reduce using rule 54 (control_structure -> switch_structure .)
    LIST            reduce using rule 54 (control_structure -> switch_structure .)
    SET             reduce using rule 54 (control_structure -> switch_structure .)
    MAP             reduce using rule 54 (control_structure -> switch_structure .)
    STACK           reduce using rule 54 (control_structure -> switch_structure .)
    QUEUE           reduce using rule 54 (control_structure -> switch_structure .)
    TREE            reduce using rule 54 (control_structure -> switch_structure .)
    GRAPH           reduce using rule 54 (control_structure -> switch_structure .)
    BOOL            reduce using rule 54 (control_structure -> switch_structure .)
    FLOAT           reduce using rule 54 (control_structure -> switch_structure .)
    INTEGER         reduce using rule 54 (control_structure -> switch_structure .)
    DOUBLE          reduce using rule 54 (control_structure -> switch_structure .)
    LSQUARE         reduce using rule 54 (control_structure -> switch_structure .)
    LBRACE          reduce using rule 54 (control_structure -> switch_structure .)
    IF              reduce using rule 54 (control_structure -> switch_structure .)
    SWITCH          reduce using rule 54 (control_structure -> switch_structure .)
    $end            reduce using rule 54 (control_structure -> switch_structure .)
    RBRACE          reduce using rule 54 (control_structure -> switch_structure .)
    BREAK           reduce using rule 54 (control_structure -> switch_structure .)


state 15

    (12) type -> VOID .

    VARIABLE        reduce using rule 12 (type -> VOID .)


state 16

    (13) type -> STRING .

    VARIABLE        reduce using rule 13 (type -> STRING .)


state 17

    (14) type -> LIST .

    VARIABLE        reduce using rule 14 (type -> LIST .)


state 18

    (15) type -> SET .

    VARIABLE        reduce using rule 15 (type -> SET .)


state 19

    (16) type -> MAP .

    VARIABLE        reduce using rule 16 (type -> MAP .)


state 20

    (17) type -> STACK .

    VARIABLE        reduce using rule 17 (type -> STACK .)


state 21

    (18) type -> QUEUE .

    VARIABLE        reduce using rule 18 (type -> QUEUE .)


state 22

    (19) type -> TREE .

    VARIABLE        reduce using rule 19 (type -> TREE .)


state 23

    (20) type -> GRAPH .

    VARIABLE        reduce using rule 20 (type -> GRAPH .)


state 24

    (21) bool_type -> BOOL .

    VARIABLE        reduce using rule 21 (bool_type -> BOOL .)


state 25

    (22) num_type -> FLOAT .

    VARIABLE        reduce using rule 22 (num_type -> FLOAT .)


state 26

    (23) num_type -> INTEGER .

    VARIABLE        reduce using rule 23 (num_type -> INTEGER .)


state 27

    (24) num_type -> DOUBLE .

    VARIABLE        reduce using rule 24 (num_type -> DOUBLE .)


state 28

    (46) list_structure -> LSQUARE . elements RSQUARE
    (48) elements -> . elements COMMA expression
    (49) elements -> . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    elements                       shift and go to state 38
    expression                     shift and go to state 39
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 29

    (47) map_structure -> LBRACE . key_value_pairs RBRACE
    (50) key_value_pairs -> . key_value_pairs COMMA key_value
    (51) key_value_pairs -> . key_value
    (52) key_value -> . expression COLON expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    key_value_pairs                shift and go to state 50
    key_value                      shift and go to state 51
    expression                     shift and go to state 52
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 30

    (55) if_structure -> IF . LPAREN condition RPAREN LBRACE statement RBRACE

    LPAREN          shift and go to state 53


state 31

    (56) switch_structure -> SWITCH . LPAREN expression RPAREN LBRACE cases default RBRACE

    LPAREN          shift and go to state 54


state 32

    (2) statements -> statements statement .

    VARIABLE        reduce using rule 2 (statements -> statements statement .)
    VOID            reduce using rule 2 (statements -> statements statement .)
    STRING          reduce using rule 2 (statements -> statements statement .)
    LIST            reduce using rule 2 (statements -> statements statement .)
    SET             reduce using rule 2 (statements -> statements statement .)
    MAP             reduce using rule 2 (statements -> statements statement .)
    STACK           reduce using rule 2 (statements -> statements statement .)
    QUEUE           reduce using rule 2 (statements -> statements statement .)
    TREE            reduce using rule 2 (statements -> statements statement .)
    GRAPH           reduce using rule 2 (statements -> statements statement .)
    BOOL            reduce using rule 2 (statements -> statements statement .)
    FLOAT           reduce using rule 2 (statements -> statements statement .)
    INTEGER         reduce using rule 2 (statements -> statements statement .)
    DOUBLE          reduce using rule 2 (statements -> statements statement .)
    LSQUARE         reduce using rule 2 (statements -> statements statement .)
    LBRACE          reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    SWITCH          reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)


state 33

    (7) var_declaration -> VARIABLE ASSIGN . expression SEMICOLON
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 55
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 34

    (8) var_declaration -> VARIABLE NULL_ASSIGN . expression SEMICOLON
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 56
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 35

    (9) var_declaration -> type VARIABLE . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 57


state 36

    (10) var_declaration -> bool_type VARIABLE . ASSIGN bool_expression SEMICOLON

    ASSIGN          shift and go to state 58


state 37

    (11) var_declaration -> num_type VARIABLE . ASSIGN num_expression SEMICOLON

    ASSIGN          shift and go to state 59


state 38

    (46) list_structure -> LSQUARE elements . RSQUARE
    (48) elements -> elements . COMMA expression

    RSQUARE         shift and go to state 60
    COMMA           shift and go to state 61


state 39

    (49) elements -> expression .

    RSQUARE         reduce using rule 49 (elements -> expression .)
    COMMA           reduce using rule 49 (elements -> expression .)


state 40

    (25) expression -> bool_expression .
    (34) bool_expression -> bool_expression . AND bool_expression
    (35) bool_expression -> bool_expression . OR bool_expression

    RSQUARE         reduce using rule 25 (expression -> bool_expression .)
    COMMA           reduce using rule 25 (expression -> bool_expression .)
    COLON           reduce using rule 25 (expression -> bool_expression .)
    SEMICOLON       reduce using rule 25 (expression -> bool_expression .)
    GREATER_THAN    reduce using rule 25 (expression -> bool_expression .)
    LESS_THAN       reduce using rule 25 (expression -> bool_expression .)
    GREATER_EQ      reduce using rule 25 (expression -> bool_expression .)
    LESS_EQ         reduce using rule 25 (expression -> bool_expression .)
    EQUALS          reduce using rule 25 (expression -> bool_expression .)
    NOT_EQUALS      reduce using rule 25 (expression -> bool_expression .)
    RPAREN          reduce using rule 25 (expression -> bool_expression .)
    RBRACE          reduce using rule 25 (expression -> bool_expression .)
    AND             shift and go to state 62
    OR              shift and go to state 63


state 41

    (26) expression -> num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

    RSQUARE         reduce using rule 26 (expression -> num_expression .)
    COMMA           reduce using rule 26 (expression -> num_expression .)
    COLON           reduce using rule 26 (expression -> num_expression .)
    SEMICOLON       reduce using rule 26 (expression -> num_expression .)
    GREATER_THAN    reduce using rule 26 (expression -> num_expression .)
    LESS_THAN       reduce using rule 26 (expression -> num_expression .)
    GREATER_EQ      reduce using rule 26 (expression -> num_expression .)
    LESS_EQ         reduce using rule 26 (expression -> num_expression .)
    EQUALS          reduce using rule 26 (expression -> num_expression .)
    NOT_EQUALS      reduce using rule 26 (expression -> num_expression .)
    RPAREN          reduce using rule 26 (expression -> num_expression .)
    RBRACE          reduce using rule 26 (expression -> num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69


state 42

    (27) expression -> VARIABLE .

    RSQUARE         reduce using rule 27 (expression -> VARIABLE .)
    COMMA           reduce using rule 27 (expression -> VARIABLE .)
    COLON           reduce using rule 27 (expression -> VARIABLE .)
    SEMICOLON       reduce using rule 27 (expression -> VARIABLE .)
    GREATER_THAN    reduce using rule 27 (expression -> VARIABLE .)
    LESS_THAN       reduce using rule 27 (expression -> VARIABLE .)
    GREATER_EQ      reduce using rule 27 (expression -> VARIABLE .)
    LESS_EQ         reduce using rule 27 (expression -> VARIABLE .)
    EQUALS          reduce using rule 27 (expression -> VARIABLE .)
    NOT_EQUALS      reduce using rule 27 (expression -> VARIABLE .)
    RPAREN          reduce using rule 27 (expression -> VARIABLE .)
    RBRACE          reduce using rule 27 (expression -> VARIABLE .)


state 43

    (28) bool_expression -> TRUE .

    AND             reduce using rule 28 (bool_expression -> TRUE .)
    OR              reduce using rule 28 (bool_expression -> TRUE .)
    RSQUARE         reduce using rule 28 (bool_expression -> TRUE .)
    COMMA           reduce using rule 28 (bool_expression -> TRUE .)
    COLON           reduce using rule 28 (bool_expression -> TRUE .)
    SEMICOLON       reduce using rule 28 (bool_expression -> TRUE .)
    RPAREN          reduce using rule 28 (bool_expression -> TRUE .)
    GREATER_THAN    reduce using rule 28 (bool_expression -> TRUE .)
    LESS_THAN       reduce using rule 28 (bool_expression -> TRUE .)
    GREATER_EQ      reduce using rule 28 (bool_expression -> TRUE .)
    LESS_EQ         reduce using rule 28 (bool_expression -> TRUE .)
    EQUALS          reduce using rule 28 (bool_expression -> TRUE .)
    NOT_EQUALS      reduce using rule 28 (bool_expression -> TRUE .)
    RBRACE          reduce using rule 28 (bool_expression -> TRUE .)


state 44

    (29) bool_expression -> FALSE .

    AND             reduce using rule 29 (bool_expression -> FALSE .)
    OR              reduce using rule 29 (bool_expression -> FALSE .)
    RSQUARE         reduce using rule 29 (bool_expression -> FALSE .)
    COMMA           reduce using rule 29 (bool_expression -> FALSE .)
    COLON           reduce using rule 29 (bool_expression -> FALSE .)
    SEMICOLON       reduce using rule 29 (bool_expression -> FALSE .)
    RPAREN          reduce using rule 29 (bool_expression -> FALSE .)
    GREATER_THAN    reduce using rule 29 (bool_expression -> FALSE .)
    LESS_THAN       reduce using rule 29 (bool_expression -> FALSE .)
    GREATER_EQ      reduce using rule 29 (bool_expression -> FALSE .)
    LESS_EQ         reduce using rule 29 (bool_expression -> FALSE .)
    EQUALS          reduce using rule 29 (bool_expression -> FALSE .)
    NOT_EQUALS      reduce using rule 29 (bool_expression -> FALSE .)
    RBRACE          reduce using rule 29 (bool_expression -> FALSE .)


state 45

    (33) bool_expression -> NEGATION . bool_expression
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 71

    bool_expression                shift and go to state 70

state 46

    (42) bool_expression -> LPAREN . bool_expression RPAREN
    (43) num_expression -> LPAREN . num_expression RPAREN
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    bool_expression                shift and go to state 72
    num_expression                 shift and go to state 73

state 47

    (30) num_expression -> NUMBER .

    PLUS            reduce using rule 30 (num_expression -> NUMBER .)
    MINUS           reduce using rule 30 (num_expression -> NUMBER .)
    TIMES           reduce using rule 30 (num_expression -> NUMBER .)
    DIVIDE          reduce using rule 30 (num_expression -> NUMBER .)
    INTEGER_DIVIDE  reduce using rule 30 (num_expression -> NUMBER .)
    MODULE          reduce using rule 30 (num_expression -> NUMBER .)
    RSQUARE         reduce using rule 30 (num_expression -> NUMBER .)
    COMMA           reduce using rule 30 (num_expression -> NUMBER .)
    COLON           reduce using rule 30 (num_expression -> NUMBER .)
    SEMICOLON       reduce using rule 30 (num_expression -> NUMBER .)
    RPAREN          reduce using rule 30 (num_expression -> NUMBER .)
    GREATER_THAN    reduce using rule 30 (num_expression -> NUMBER .)
    LESS_THAN       reduce using rule 30 (num_expression -> NUMBER .)
    GREATER_EQ      reduce using rule 30 (num_expression -> NUMBER .)
    LESS_EQ         reduce using rule 30 (num_expression -> NUMBER .)
    EQUALS          reduce using rule 30 (num_expression -> NUMBER .)
    NOT_EQUALS      reduce using rule 30 (num_expression -> NUMBER .)
    RBRACE          reduce using rule 30 (num_expression -> NUMBER .)


state 48

    (31) num_expression -> INTEGER .

    PLUS            reduce using rule 31 (num_expression -> INTEGER .)
    MINUS           reduce using rule 31 (num_expression -> INTEGER .)
    TIMES           reduce using rule 31 (num_expression -> INTEGER .)
    DIVIDE          reduce using rule 31 (num_expression -> INTEGER .)
    INTEGER_DIVIDE  reduce using rule 31 (num_expression -> INTEGER .)
    MODULE          reduce using rule 31 (num_expression -> INTEGER .)
    RSQUARE         reduce using rule 31 (num_expression -> INTEGER .)
    COMMA           reduce using rule 31 (num_expression -> INTEGER .)
    COLON           reduce using rule 31 (num_expression -> INTEGER .)
    SEMICOLON       reduce using rule 31 (num_expression -> INTEGER .)
    RPAREN          reduce using rule 31 (num_expression -> INTEGER .)
    GREATER_THAN    reduce using rule 31 (num_expression -> INTEGER .)
    LESS_THAN       reduce using rule 31 (num_expression -> INTEGER .)
    GREATER_EQ      reduce using rule 31 (num_expression -> INTEGER .)
    LESS_EQ         reduce using rule 31 (num_expression -> INTEGER .)
    EQUALS          reduce using rule 31 (num_expression -> INTEGER .)
    NOT_EQUALS      reduce using rule 31 (num_expression -> INTEGER .)
    RBRACE          reduce using rule 31 (num_expression -> INTEGER .)


state 49

    (32) num_expression -> FLOAT .

    PLUS            reduce using rule 32 (num_expression -> FLOAT .)
    MINUS           reduce using rule 32 (num_expression -> FLOAT .)
    TIMES           reduce using rule 32 (num_expression -> FLOAT .)
    DIVIDE          reduce using rule 32 (num_expression -> FLOAT .)
    INTEGER_DIVIDE  reduce using rule 32 (num_expression -> FLOAT .)
    MODULE          reduce using rule 32 (num_expression -> FLOAT .)
    RSQUARE         reduce using rule 32 (num_expression -> FLOAT .)
    COMMA           reduce using rule 32 (num_expression -> FLOAT .)
    COLON           reduce using rule 32 (num_expression -> FLOAT .)
    SEMICOLON       reduce using rule 32 (num_expression -> FLOAT .)
    RPAREN          reduce using rule 32 (num_expression -> FLOAT .)
    GREATER_THAN    reduce using rule 32 (num_expression -> FLOAT .)
    LESS_THAN       reduce using rule 32 (num_expression -> FLOAT .)
    GREATER_EQ      reduce using rule 32 (num_expression -> FLOAT .)
    LESS_EQ         reduce using rule 32 (num_expression -> FLOAT .)
    EQUALS          reduce using rule 32 (num_expression -> FLOAT .)
    NOT_EQUALS      reduce using rule 32 (num_expression -> FLOAT .)
    RBRACE          reduce using rule 32 (num_expression -> FLOAT .)


state 50

    (47) map_structure -> LBRACE key_value_pairs . RBRACE
    (50) key_value_pairs -> key_value_pairs . COMMA key_value

    RBRACE          shift and go to state 74
    COMMA           shift and go to state 75


state 51

    (51) key_value_pairs -> key_value .

    RBRACE          reduce using rule 51 (key_value_pairs -> key_value .)
    COMMA           reduce using rule 51 (key_value_pairs -> key_value .)


state 52

    (52) key_value -> expression . COLON expression

    COLON           shift and go to state 76


state 53

    (55) if_structure -> IF LPAREN . condition RPAREN LBRACE statement RBRACE
    (57) condition -> . expression GREATER_THAN expression
    (58) condition -> . expression LESS_THAN expression
    (59) condition -> . expression GREATER_EQ expression
    (60) condition -> . expression LESS_EQ expression
    (61) condition -> . expression EQUALS expression
    (62) condition -> . expression NOT_EQUALS expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    condition                      shift and go to state 77
    expression                     shift and go to state 78
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 54

    (56) switch_structure -> SWITCH LPAREN . expression RPAREN LBRACE cases default RBRACE
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 79
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 55

    (7) var_declaration -> VARIABLE ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 80


state 56

    (8) var_declaration -> VARIABLE NULL_ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 81


state 57

    (9) var_declaration -> type VARIABLE ASSIGN . expression SEMICOLON
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 82
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 58

    (10) var_declaration -> bool_type VARIABLE ASSIGN . bool_expression SEMICOLON
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 71

    bool_expression                shift and go to state 83

state 59

    (11) var_declaration -> num_type VARIABLE ASSIGN . num_expression SEMICOLON
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 84

state 60

    (46) list_structure -> LSQUARE elements RSQUARE .

    VARIABLE        reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    VOID            reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    STRING          reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    LIST            reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    SET             reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    MAP             reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    STACK           reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    QUEUE           reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    TREE            reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    GRAPH           reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    BOOL            reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    FLOAT           reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    INTEGER         reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    DOUBLE          reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    LSQUARE         reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    LBRACE          reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    IF              reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    SWITCH          reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    $end            reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    RBRACE          reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)
    BREAK           reduce using rule 46 (list_structure -> LSQUARE elements RSQUARE .)


state 61

    (48) elements -> elements COMMA . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 86
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 62

    (34) bool_expression -> bool_expression AND . bool_expression
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 71

    bool_expression                shift and go to state 87

state 63

    (35) bool_expression -> bool_expression OR . bool_expression
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 71

    bool_expression                shift and go to state 88

state 64

    (36) num_expression -> num_expression PLUS . num_expression
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 89

state 65

    (37) num_expression -> num_expression MINUS . num_expression
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 90

state 66

    (38) num_expression -> num_expression TIMES . num_expression
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 91

state 67

    (39) num_expression -> num_expression DIVIDE . num_expression
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 92

state 68

    (40) num_expression -> num_expression INTEGER_DIVIDE . num_expression
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 93

state 69

    (41) num_expression -> num_expression MODULE . num_expression
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 94

state 70

    (33) bool_expression -> NEGATION bool_expression .
    (34) bool_expression -> bool_expression . AND bool_expression
    (35) bool_expression -> bool_expression . OR bool_expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RSQUARE         reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    COMMA           reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    COLON           reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    SEMICOLON       reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    RPAREN          reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    GREATER_THAN    reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    LESS_THAN       reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    GREATER_EQ      reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    LESS_EQ         reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    EQUALS          reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    NOT_EQUALS      reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    RBRACE          reduce using rule 33 (bool_expression -> NEGATION bool_expression .)
    AND             shift and go to state 62
    OR              shift and go to state 63

  ! AND             [ reduce using rule 33 (bool_expression -> NEGATION bool_expression .) ]
  ! OR              [ reduce using rule 33 (bool_expression -> NEGATION bool_expression .) ]


state 71

    (42) bool_expression -> LPAREN . bool_expression RPAREN
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN

    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 71

    bool_expression                shift and go to state 72

state 72

    (42) bool_expression -> LPAREN bool_expression . RPAREN
    (34) bool_expression -> bool_expression . AND bool_expression
    (35) bool_expression -> bool_expression . OR bool_expression

    RPAREN          shift and go to state 95
    AND             shift and go to state 62
    OR              shift and go to state 63


state 73

    (43) num_expression -> LPAREN num_expression . RPAREN
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

    RPAREN          shift and go to state 96
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69


state 74

    (47) map_structure -> LBRACE key_value_pairs RBRACE .

    VARIABLE        reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    VOID            reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    STRING          reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    LIST            reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    SET             reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    MAP             reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    STACK           reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    QUEUE           reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    TREE            reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    GRAPH           reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    BOOL            reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    FLOAT           reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    INTEGER         reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    DOUBLE          reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    LSQUARE         reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    LBRACE          reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    IF              reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    SWITCH          reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    $end            reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    RBRACE          reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)
    BREAK           reduce using rule 47 (map_structure -> LBRACE key_value_pairs RBRACE .)


state 75

    (50) key_value_pairs -> key_value_pairs COMMA . key_value
    (52) key_value -> . expression COLON expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    key_value                      shift and go to state 97
    expression                     shift and go to state 52
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 76

    (52) key_value -> expression COLON . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 98
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 77

    (55) if_structure -> IF LPAREN condition . RPAREN LBRACE statement RBRACE

    RPAREN          shift and go to state 99


state 78

    (57) condition -> expression . GREATER_THAN expression
    (58) condition -> expression . LESS_THAN expression
    (59) condition -> expression . GREATER_EQ expression
    (60) condition -> expression . LESS_EQ expression
    (61) condition -> expression . EQUALS expression
    (62) condition -> expression . NOT_EQUALS expression

    GREATER_THAN    shift and go to state 100
    LESS_THAN       shift and go to state 101
    GREATER_EQ      shift and go to state 102
    LESS_EQ         shift and go to state 103
    EQUALS          shift and go to state 104
    NOT_EQUALS      shift and go to state 105


state 79

    (56) switch_structure -> SWITCH LPAREN expression . RPAREN LBRACE cases default RBRACE

    RPAREN          shift and go to state 106


state 80

    (7) var_declaration -> VARIABLE ASSIGN expression SEMICOLON .

    VARIABLE        reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    SET             reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    STACK           reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    QUEUE           reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    TREE            reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    GRAPH           reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    IF              reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    SWITCH          reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    $end            reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 7 (var_declaration -> VARIABLE ASSIGN expression SEMICOLON .)


state 81

    (8) var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .

    VARIABLE        reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    SET             reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    STACK           reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    QUEUE           reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    TREE            reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    GRAPH           reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    IF              reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    SWITCH          reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    $end            reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 8 (var_declaration -> VARIABLE NULL_ASSIGN expression SEMICOLON .)


state 82

    (9) var_declaration -> type VARIABLE ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 107


state 83

    (10) var_declaration -> bool_type VARIABLE ASSIGN bool_expression . SEMICOLON
    (34) bool_expression -> bool_expression . AND bool_expression
    (35) bool_expression -> bool_expression . OR bool_expression

    SEMICOLON       shift and go to state 108
    AND             shift and go to state 62
    OR              shift and go to state 63


state 84

    (11) var_declaration -> num_type VARIABLE ASSIGN num_expression . SEMICOLON
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

    SEMICOLON       shift and go to state 109
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69


state 85

    (43) num_expression -> LPAREN . num_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    LPAREN          shift and go to state 85

    num_expression                 shift and go to state 73

state 86

    (48) elements -> elements COMMA expression .

    RSQUARE         reduce using rule 48 (elements -> elements COMMA expression .)
    COMMA           reduce using rule 48 (elements -> elements COMMA expression .)


state 87

    (34) bool_expression -> bool_expression AND bool_expression .
    (34) bool_expression -> bool_expression . AND bool_expression
    (35) bool_expression -> bool_expression . OR bool_expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RSQUARE         reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    COMMA           reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    COLON           reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    SEMICOLON       reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    RPAREN          reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    GREATER_THAN    reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    LESS_THAN       reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    GREATER_EQ      reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    LESS_EQ         reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    EQUALS          reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    NOT_EQUALS      reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    RBRACE          reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .)
    AND             shift and go to state 62
    OR              shift and go to state 63

  ! AND             [ reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .) ]
  ! OR              [ reduce using rule 34 (bool_expression -> bool_expression AND bool_expression .) ]


state 88

    (35) bool_expression -> bool_expression OR bool_expression .
    (34) bool_expression -> bool_expression . AND bool_expression
    (35) bool_expression -> bool_expression . OR bool_expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RSQUARE         reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    COMMA           reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    COLON           reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    SEMICOLON       reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    RPAREN          reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    GREATER_THAN    reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    LESS_THAN       reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    GREATER_EQ      reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    LESS_EQ         reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    EQUALS          reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    NOT_EQUALS      reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    RBRACE          reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .)
    AND             shift and go to state 62
    OR              shift and go to state 63

  ! AND             [ reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .) ]
  ! OR              [ reduce using rule 35 (bool_expression -> bool_expression OR bool_expression .) ]


state 89

    (36) num_expression -> num_expression PLUS num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    COMMA           reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    COLON           reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    SEMICOLON       reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    RPAREN          reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    GREATER_THAN    reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    LESS_THAN       reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    GREATER_EQ      reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    LESS_EQ         reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    EQUALS          reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    NOT_EQUALS      reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    RBRACE          reduce using rule 36 (num_expression -> num_expression PLUS num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69

  ! PLUS            [ reduce using rule 36 (num_expression -> num_expression PLUS num_expression .) ]
  ! MINUS           [ reduce using rule 36 (num_expression -> num_expression PLUS num_expression .) ]
  ! TIMES           [ reduce using rule 36 (num_expression -> num_expression PLUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 36 (num_expression -> num_expression PLUS num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 36 (num_expression -> num_expression PLUS num_expression .) ]
  ! MODULE          [ reduce using rule 36 (num_expression -> num_expression PLUS num_expression .) ]


state 90

    (37) num_expression -> num_expression MINUS num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    COMMA           reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    COLON           reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    SEMICOLON       reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    RPAREN          reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    GREATER_THAN    reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    LESS_THAN       reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    GREATER_EQ      reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    LESS_EQ         reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    EQUALS          reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    NOT_EQUALS      reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    RBRACE          reduce using rule 37 (num_expression -> num_expression MINUS num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69

  ! PLUS            [ reduce using rule 37 (num_expression -> num_expression MINUS num_expression .) ]
  ! MINUS           [ reduce using rule 37 (num_expression -> num_expression MINUS num_expression .) ]
  ! TIMES           [ reduce using rule 37 (num_expression -> num_expression MINUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 37 (num_expression -> num_expression MINUS num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 37 (num_expression -> num_expression MINUS num_expression .) ]
  ! MODULE          [ reduce using rule 37 (num_expression -> num_expression MINUS num_expression .) ]


state 91

    (38) num_expression -> num_expression TIMES num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    COMMA           reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    COLON           reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    SEMICOLON       reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    RPAREN          reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    GREATER_THAN    reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    LESS_THAN       reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    GREATER_EQ      reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    LESS_EQ         reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    EQUALS          reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    NOT_EQUALS      reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    RBRACE          reduce using rule 38 (num_expression -> num_expression TIMES num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69

  ! PLUS            [ reduce using rule 38 (num_expression -> num_expression TIMES num_expression .) ]
  ! MINUS           [ reduce using rule 38 (num_expression -> num_expression TIMES num_expression .) ]
  ! TIMES           [ reduce using rule 38 (num_expression -> num_expression TIMES num_expression .) ]
  ! DIVIDE          [ reduce using rule 38 (num_expression -> num_expression TIMES num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 38 (num_expression -> num_expression TIMES num_expression .) ]
  ! MODULE          [ reduce using rule 38 (num_expression -> num_expression TIMES num_expression .) ]


state 92

    (39) num_expression -> num_expression DIVIDE num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    COMMA           reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    COLON           reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    SEMICOLON       reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    RPAREN          reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    GREATER_THAN    reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    LESS_THAN       reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    GREATER_EQ      reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    LESS_EQ         reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    EQUALS          reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    NOT_EQUALS      reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    RBRACE          reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69

  ! PLUS            [ reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! MINUS           [ reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! TIMES           [ reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! DIVIDE          [ reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .) ]
  ! MODULE          [ reduce using rule 39 (num_expression -> num_expression DIVIDE num_expression .) ]


state 93

    (40) num_expression -> num_expression INTEGER_DIVIDE num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    COMMA           reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    COLON           reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    SEMICOLON       reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    RPAREN          reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    GREATER_THAN    reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    LESS_THAN       reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    GREATER_EQ      reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    LESS_EQ         reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    EQUALS          reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    NOT_EQUALS      reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    RBRACE          reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69

  ! PLUS            [ reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! MINUS           [ reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! TIMES           [ reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! DIVIDE          [ reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]
  ! MODULE          [ reduce using rule 40 (num_expression -> num_expression INTEGER_DIVIDE num_expression .) ]


state 94

    (41) num_expression -> num_expression MODULE num_expression .
    (36) num_expression -> num_expression . PLUS num_expression
    (37) num_expression -> num_expression . MINUS num_expression
    (38) num_expression -> num_expression . TIMES num_expression
    (39) num_expression -> num_expression . DIVIDE num_expression
    (40) num_expression -> num_expression . INTEGER_DIVIDE num_expression
    (41) num_expression -> num_expression . MODULE num_expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for INTEGER_DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    RSQUARE         reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    COMMA           reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    COLON           reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    SEMICOLON       reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    RPAREN          reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    GREATER_THAN    reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    LESS_THAN       reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    GREATER_EQ      reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    LESS_EQ         reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    EQUALS          reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    NOT_EQUALS      reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    RBRACE          reduce using rule 41 (num_expression -> num_expression MODULE num_expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    INTEGER_DIVIDE  shift and go to state 68
    MODULE          shift and go to state 69

  ! PLUS            [ reduce using rule 41 (num_expression -> num_expression MODULE num_expression .) ]
  ! MINUS           [ reduce using rule 41 (num_expression -> num_expression MODULE num_expression .) ]
  ! TIMES           [ reduce using rule 41 (num_expression -> num_expression MODULE num_expression .) ]
  ! DIVIDE          [ reduce using rule 41 (num_expression -> num_expression MODULE num_expression .) ]
  ! INTEGER_DIVIDE  [ reduce using rule 41 (num_expression -> num_expression MODULE num_expression .) ]
  ! MODULE          [ reduce using rule 41 (num_expression -> num_expression MODULE num_expression .) ]


state 95

    (42) bool_expression -> LPAREN bool_expression RPAREN .

    AND             reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    OR              reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    RSQUARE         reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    COMMA           reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    COLON           reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    SEMICOLON       reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    RPAREN          reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    GREATER_THAN    reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    LESS_THAN       reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    GREATER_EQ      reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    LESS_EQ         reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    EQUALS          reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    NOT_EQUALS      reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)
    RBRACE          reduce using rule 42 (bool_expression -> LPAREN bool_expression RPAREN .)


state 96

    (43) num_expression -> LPAREN num_expression RPAREN .

    PLUS            reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    MINUS           reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    TIMES           reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    DIVIDE          reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    INTEGER_DIVIDE  reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    MODULE          reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    RSQUARE         reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    COMMA           reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    COLON           reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    SEMICOLON       reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    RPAREN          reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    GREATER_THAN    reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    LESS_THAN       reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    GREATER_EQ      reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    LESS_EQ         reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    EQUALS          reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    NOT_EQUALS      reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)
    RBRACE          reduce using rule 43 (num_expression -> LPAREN num_expression RPAREN .)


state 97

    (50) key_value_pairs -> key_value_pairs COMMA key_value .

    RBRACE          reduce using rule 50 (key_value_pairs -> key_value_pairs COMMA key_value .)
    COMMA           reduce using rule 50 (key_value_pairs -> key_value_pairs COMMA key_value .)


state 98

    (52) key_value -> expression COLON expression .

    RBRACE          reduce using rule 52 (key_value -> expression COLON expression .)
    COMMA           reduce using rule 52 (key_value -> expression COLON expression .)


state 99

    (55) if_structure -> IF LPAREN condition RPAREN . LBRACE statement RBRACE

    LBRACE          shift and go to state 110


state 100

    (57) condition -> expression GREATER_THAN . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 111
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 101

    (58) condition -> expression LESS_THAN . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 112
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 102

    (59) condition -> expression GREATER_EQ . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 113
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 103

    (60) condition -> expression LESS_EQ . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 114
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 104

    (61) condition -> expression EQUALS . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 115
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 105

    (62) condition -> expression NOT_EQUALS . expression
    (25) expression -> . bool_expression
    (26) expression -> . num_expression
    (27) expression -> . VARIABLE
    (28) bool_expression -> . TRUE
    (29) bool_expression -> . FALSE
    (33) bool_expression -> . NEGATION bool_expression
    (34) bool_expression -> . bool_expression AND bool_expression
    (35) bool_expression -> . bool_expression OR bool_expression
    (42) bool_expression -> . LPAREN bool_expression RPAREN
    (30) num_expression -> . NUMBER
    (31) num_expression -> . INTEGER
    (32) num_expression -> . FLOAT
    (36) num_expression -> . num_expression PLUS num_expression
    (37) num_expression -> . num_expression MINUS num_expression
    (38) num_expression -> . num_expression TIMES num_expression
    (39) num_expression -> . num_expression DIVIDE num_expression
    (40) num_expression -> . num_expression INTEGER_DIVIDE num_expression
    (41) num_expression -> . num_expression MODULE num_expression
    (43) num_expression -> . LPAREN num_expression RPAREN

    VARIABLE        shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44
    NEGATION        shift and go to state 45
    LPAREN          shift and go to state 46
    NUMBER          shift and go to state 47
    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49

    expression                     shift and go to state 116
    bool_expression                shift and go to state 40
    num_expression                 shift and go to state 41

state 106

    (56) switch_structure -> SWITCH LPAREN expression RPAREN . LBRACE cases default RBRACE

    LBRACE          shift and go to state 117


state 107

    (9) var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .

    VARIABLE        reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    SET             reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    STACK           reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    QUEUE           reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    TREE            reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    GRAPH           reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    LSQUARE         reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    IF              reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    SWITCH          reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    $end            reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)
    BREAK           reduce using rule 9 (var_declaration -> type VARIABLE ASSIGN expression SEMICOLON .)


state 108

    (10) var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .

    VARIABLE        reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    VOID            reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    STRING          reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    LIST            reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    SET             reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    MAP             reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    STACK           reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    QUEUE           reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    TREE            reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    GRAPH           reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    BOOL            reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    FLOAT           reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    INTEGER         reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    DOUBLE          reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    LSQUARE         reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    LBRACE          reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    IF              reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    SWITCH          reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    $end            reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    RBRACE          reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)
    BREAK           reduce using rule 10 (var_declaration -> bool_type VARIABLE ASSIGN bool_expression SEMICOLON .)


state 109

    (11) var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .

    VARIABLE        reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    VOID            reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    STRING          reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    LIST            reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    SET             reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    MAP             reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    STACK           reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    QUEUE           reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    TREE            reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    GRAPH           reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    BOOL            reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    FLOAT           reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    INTEGER         reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    DOUBLE          reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    LSQUARE         reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    LBRACE          reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    IF              reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    SWITCH          reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    $end            reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    RBRACE          reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)
    BREAK           reduce using rule 11 (var_declaration -> num_type VARIABLE ASSIGN num_expression SEMICOLON .)


state 110

    (55) if_structure -> IF LPAREN condition RPAREN LBRACE . statement RBRACE
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) statement -> . control_structure
    (7) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (8) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (9) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (10) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (11) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (44) data_structure -> . list_structure
    (45) data_structure -> . map_structure
    (53) control_structure -> . if_structure
    (54) control_structure -> . switch_structure
    (12) type -> . VOID
    (13) type -> . STRING
    (14) type -> . LIST
    (15) type -> . SET
    (16) type -> . MAP
    (17) type -> . STACK
    (18) type -> . QUEUE
    (19) type -> . TREE
    (20) type -> . GRAPH
    (21) bool_type -> . BOOL
    (22) num_type -> . FLOAT
    (23) num_type -> . INTEGER
    (24) num_type -> . DOUBLE
    (46) list_structure -> . LSQUARE elements RSQUARE
    (47) map_structure -> . LBRACE key_value_pairs RBRACE
    (55) if_structure -> . IF LPAREN condition RPAREN LBRACE statement RBRACE
    (56) switch_structure -> . SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE

    VARIABLE        shift and go to state 7
    VOID            shift and go to state 15
    STRING          shift and go to state 16
    LIST            shift and go to state 17
    SET             shift and go to state 18
    MAP             shift and go to state 19
    STACK           shift and go to state 20
    QUEUE           shift and go to state 21
    TREE            shift and go to state 22
    GRAPH           shift and go to state 23
    BOOL            shift and go to state 24
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 26
    DOUBLE          shift and go to state 27
    LSQUARE         shift and go to state 28
    LBRACE          shift and go to state 29
    IF              shift and go to state 30
    SWITCH          shift and go to state 31

    statement                      shift and go to state 118
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    control_structure              shift and go to state 6
    type                           shift and go to state 8
    bool_type                      shift and go to state 9
    num_type                       shift and go to state 10
    list_structure                 shift and go to state 11
    map_structure                  shift and go to state 12
    if_structure                   shift and go to state 13
    switch_structure               shift and go to state 14

state 111

    (57) condition -> expression GREATER_THAN expression .

    RPAREN          reduce using rule 57 (condition -> expression GREATER_THAN expression .)


state 112

    (58) condition -> expression LESS_THAN expression .

    RPAREN          reduce using rule 58 (condition -> expression LESS_THAN expression .)


state 113

    (59) condition -> expression GREATER_EQ expression .

    RPAREN          reduce using rule 59 (condition -> expression GREATER_EQ expression .)


state 114

    (60) condition -> expression LESS_EQ expression .

    RPAREN          reduce using rule 60 (condition -> expression LESS_EQ expression .)


state 115

    (61) condition -> expression EQUALS expression .

    RPAREN          reduce using rule 61 (condition -> expression EQUALS expression .)


state 116

    (62) condition -> expression NOT_EQUALS expression .

    RPAREN          reduce using rule 62 (condition -> expression NOT_EQUALS expression .)


state 117

    (56) switch_structure -> SWITCH LPAREN expression RPAREN LBRACE . cases default RBRACE
    (63) cases -> . cases case
    (64) cases -> . case
    (65) case -> . CASE NUMBER COLON statement BREAK SEMICOLON

    CASE            shift and go to state 121

    cases                          shift and go to state 119
    case                           shift and go to state 120

state 118

    (55) if_structure -> IF LPAREN condition RPAREN LBRACE statement . RBRACE

    RBRACE          shift and go to state 122


state 119

    (56) switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases . default RBRACE
    (63) cases -> cases . case
    (66) default -> . DEFAULT COLON statement
    (67) default -> . empty
    (65) case -> . CASE NUMBER COLON statement BREAK SEMICOLON
    (68) empty -> .

    DEFAULT         shift and go to state 125
    CASE            shift and go to state 121
    RBRACE          reduce using rule 68 (empty -> .)

    default                        shift and go to state 123
    case                           shift and go to state 124
    empty                          shift and go to state 126

state 120

    (64) cases -> case .

    DEFAULT         reduce using rule 64 (cases -> case .)
    CASE            reduce using rule 64 (cases -> case .)
    RBRACE          reduce using rule 64 (cases -> case .)


state 121

    (65) case -> CASE . NUMBER COLON statement BREAK SEMICOLON

    NUMBER          shift and go to state 127


state 122

    (55) if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .

    VARIABLE        reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    VOID            reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    STRING          reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    LIST            reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    SET             reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    MAP             reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    STACK           reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    QUEUE           reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    TREE            reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    GRAPH           reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    BOOL            reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    FLOAT           reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    INTEGER         reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    DOUBLE          reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    LSQUARE         reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    LBRACE          reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    IF              reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    SWITCH          reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    $end            reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    RBRACE          reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)
    BREAK           reduce using rule 55 (if_structure -> IF LPAREN condition RPAREN LBRACE statement RBRACE .)


state 123

    (56) switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default . RBRACE

    RBRACE          shift and go to state 128


state 124

    (63) cases -> cases case .

    DEFAULT         reduce using rule 63 (cases -> cases case .)
    CASE            reduce using rule 63 (cases -> cases case .)
    RBRACE          reduce using rule 63 (cases -> cases case .)


state 125

    (66) default -> DEFAULT . COLON statement

    COLON           shift and go to state 129


state 126

    (67) default -> empty .

    RBRACE          reduce using rule 67 (default -> empty .)


state 127

    (65) case -> CASE NUMBER . COLON statement BREAK SEMICOLON

    COLON           shift and go to state 130


state 128

    (56) switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .

    VARIABLE        reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    VOID            reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    STRING          reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    LIST            reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    SET             reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    MAP             reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    STACK           reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    QUEUE           reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    TREE            reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    GRAPH           reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    BOOL            reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    FLOAT           reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    INTEGER         reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    DOUBLE          reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    LSQUARE         reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    LBRACE          reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    IF              reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    SWITCH          reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    $end            reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    RBRACE          reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)
    BREAK           reduce using rule 56 (switch_structure -> SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE .)


state 129

    (66) default -> DEFAULT COLON . statement
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) statement -> . control_structure
    (7) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (8) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (9) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (10) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (11) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (44) data_structure -> . list_structure
    (45) data_structure -> . map_structure
    (53) control_structure -> . if_structure
    (54) control_structure -> . switch_structure
    (12) type -> . VOID
    (13) type -> . STRING
    (14) type -> . LIST
    (15) type -> . SET
    (16) type -> . MAP
    (17) type -> . STACK
    (18) type -> . QUEUE
    (19) type -> . TREE
    (20) type -> . GRAPH
    (21) bool_type -> . BOOL
    (22) num_type -> . FLOAT
    (23) num_type -> . INTEGER
    (24) num_type -> . DOUBLE
    (46) list_structure -> . LSQUARE elements RSQUARE
    (47) map_structure -> . LBRACE key_value_pairs RBRACE
    (55) if_structure -> . IF LPAREN condition RPAREN LBRACE statement RBRACE
    (56) switch_structure -> . SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE

    VARIABLE        shift and go to state 7
    VOID            shift and go to state 15
    STRING          shift and go to state 16
    LIST            shift and go to state 17
    SET             shift and go to state 18
    MAP             shift and go to state 19
    STACK           shift and go to state 20
    QUEUE           shift and go to state 21
    TREE            shift and go to state 22
    GRAPH           shift and go to state 23
    BOOL            shift and go to state 24
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 26
    DOUBLE          shift and go to state 27
    LSQUARE         shift and go to state 28
    LBRACE          shift and go to state 29
    IF              shift and go to state 30
    SWITCH          shift and go to state 31

    statement                      shift and go to state 131
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    control_structure              shift and go to state 6
    type                           shift and go to state 8
    bool_type                      shift and go to state 9
    num_type                       shift and go to state 10
    list_structure                 shift and go to state 11
    map_structure                  shift and go to state 12
    if_structure                   shift and go to state 13
    switch_structure               shift and go to state 14

state 130

    (65) case -> CASE NUMBER COLON . statement BREAK SEMICOLON
    (4) statement -> . var_declaration
    (5) statement -> . data_structure
    (6) statement -> . control_structure
    (7) var_declaration -> . VARIABLE ASSIGN expression SEMICOLON
    (8) var_declaration -> . VARIABLE NULL_ASSIGN expression SEMICOLON
    (9) var_declaration -> . type VARIABLE ASSIGN expression SEMICOLON
    (10) var_declaration -> . bool_type VARIABLE ASSIGN bool_expression SEMICOLON
    (11) var_declaration -> . num_type VARIABLE ASSIGN num_expression SEMICOLON
    (44) data_structure -> . list_structure
    (45) data_structure -> . map_structure
    (53) control_structure -> . if_structure
    (54) control_structure -> . switch_structure
    (12) type -> . VOID
    (13) type -> . STRING
    (14) type -> . LIST
    (15) type -> . SET
    (16) type -> . MAP
    (17) type -> . STACK
    (18) type -> . QUEUE
    (19) type -> . TREE
    (20) type -> . GRAPH
    (21) bool_type -> . BOOL
    (22) num_type -> . FLOAT
    (23) num_type -> . INTEGER
    (24) num_type -> . DOUBLE
    (46) list_structure -> . LSQUARE elements RSQUARE
    (47) map_structure -> . LBRACE key_value_pairs RBRACE
    (55) if_structure -> . IF LPAREN condition RPAREN LBRACE statement RBRACE
    (56) switch_structure -> . SWITCH LPAREN expression RPAREN LBRACE cases default RBRACE

    VARIABLE        shift and go to state 7
    VOID            shift and go to state 15
    STRING          shift and go to state 16
    LIST            shift and go to state 17
    SET             shift and go to state 18
    MAP             shift and go to state 19
    STACK           shift and go to state 20
    QUEUE           shift and go to state 21
    TREE            shift and go to state 22
    GRAPH           shift and go to state 23
    BOOL            shift and go to state 24
    FLOAT           shift and go to state 25
    INTEGER         shift and go to state 26
    DOUBLE          shift and go to state 27
    LSQUARE         shift and go to state 28
    LBRACE          shift and go to state 29
    IF              shift and go to state 30
    SWITCH          shift and go to state 31

    statement                      shift and go to state 132
    var_declaration                shift and go to state 4
    data_structure                 shift and go to state 5
    control_structure              shift and go to state 6
    type                           shift and go to state 8
    bool_type                      shift and go to state 9
    num_type                       shift and go to state 10
    list_structure                 shift and go to state 11
    map_structure                  shift and go to state 12
    if_structure                   shift and go to state 13
    switch_structure               shift and go to state 14

state 131

    (66) default -> DEFAULT COLON statement .

    RBRACE          reduce using rule 66 (default -> DEFAULT COLON statement .)


state 132

    (65) case -> CASE NUMBER COLON statement . BREAK SEMICOLON

    BREAK           shift and go to state 133


state 133

    (65) case -> CASE NUMBER COLON statement BREAK . SEMICOLON

    SEMICOLON       shift and go to state 134


state 134

    (65) case -> CASE NUMBER COLON statement BREAK SEMICOLON .

    DEFAULT         reduce using rule 65 (case -> CASE NUMBER COLON statement BREAK SEMICOLON .)
    CASE            reduce using rule 65 (case -> CASE NUMBER COLON statement BREAK SEMICOLON .)
    RBRACE          reduce using rule 65 (case -> CASE NUMBER COLON statement BREAK SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 70 resolved as shift
WARNING: shift/reduce conflict for OR in state 70 resolved as shift
WARNING: shift/reduce conflict for AND in state 87 resolved as shift
WARNING: shift/reduce conflict for OR in state 87 resolved as shift
WARNING: shift/reduce conflict for AND in state 88 resolved as shift
WARNING: shift/reduce conflict for OR in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 89 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 89 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 89 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 89 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 89 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 89 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 90 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 90 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 90 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 91 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 91 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 91 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 91 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 91 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 91 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 92 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 92 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 92 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 92 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 92 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 92 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 93 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 93 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 93 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 93 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 93 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 93 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 94 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 94 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 94 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 94 resolved as shift
WARNING: shift/reduce conflict for INTEGER_DIVIDE in state 94 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 94 resolved as shift
